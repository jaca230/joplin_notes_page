
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						<link rel="stylesheet" href="pluginAssets/jsdraw__markdownIt_editDrawingButton/markdownIt.css"><script type="application/javascript" src="pluginAssets/jsdraw__markdownIt_editDrawingButton/markdownIt-content.js"></script><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>20/07/2025 - 26/07/2025</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">20/07/2025 - 26/07/2025</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir Next', 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}

		:root {
			--scrollbar-size: 7px;
		}

		::-webkit-scrollbar {
			width: var(--scrollbar-size);
			height: var(--scrollbar-size);
		}
		::-webkit-scrollbar-thumb {
			border-radius: calc(var(--scrollbar-size) / 2);
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(50, 55, 63, 0.54); 
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(50, 55, 63, 0.63); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
			font-weight: bold;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		dt {
			font-weight: bold;
			margin-bottom: 0.25em;
		}

		dd {
			margin-inline-start: 2.5em;
			margin-bottom: 0.5em;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to prevent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir Next', 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		
	.not-loaded-resource img {
		width: 1.15em;
		height: 1.15em;
		background: white;
		padding: 2px !important;
		border-radius: 2px;
		box-shadow: 0 1px 3px #000000aa;
	}

	a.not-loaded-resource img {
		margin-right: .2em;
	}

	a.not-loaded-resource {
		display: flex;
		flex-direction: row;
		align-items: center;
	}


		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 35rem;
			width: 100%;
			max-width: 1000px;
			margin: 0;
			border: 0;
			display: block;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		.joplin-table-wrapper{
			overflow-x: auto;
			overflow-y: hidden;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
					position: relative;
					top: 1px;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}
.mermaid { width: 640px; }
pre.mermaid[data-processed=true] { white-space: unset; }
.mermaid-export-graph {
					opacity: 0;
					height: 0;
					z-index: 1;
					position: relative;
				} 
				.joplin-editable:hover .mermaid-export-graph,
				.joplin-editable .mermaid-export-graph:has(:focus-visible) {
					opacity: 1;
				}
				.mermaid-export-graph > button:hover {
					background-color: #CBDAF1 !important;
				}</style><div id="rendered-md"><h2 id="23072025-1456">23/07/2025 14:56</h2>
<h1 id="unpacker-stages-core">unpacker-stages-core</h1>
<h2 id="1-handle-field-mapping-properly">1. Handle Field Mapping properly</h2>
<p>a. Forward declared (no ROOT needed)<br>
b. Switch cases for variety of member types<br>
i. Some way to handle vector types<br>
c. Endianness handled efficiently, need:<br>
i. Figure out system endianness (system packages?)<br>
ii. Flip endianness only if needed (can handle this with conditional build shifts?)</p>
<h2 id="2-bytestreamprocessorstage">2. ByteStreamProcessorStage</h2>
<p>a. Gives protected methods to go from config ⇒ DataProduct</p>
<hr>
<h1 id="unpacker-stages-nalu">unpacker-stages-nalu</h1>
<h2 id="1-provides-classes-derived-from-bytestreamprocessorstage-to-unpack-bytestream">1. Provides classes derived from ByteStreamProcessorStage to unpack bytestream</h2>
<p>a. <code class="inline-code">NaluEventHeaderUnpackerStage</code> (maybe can use below “simple dataproduct core”)<br>
i. Forms <code class="inline-code">NaluPacketHeader</code>, <code class="inline-code">NaluPacketPayload</code>, <code class="inline-code">NaluPacketFooter</code> for each packet<br>
ii. Uses info in <code class="inline-code">NaluEventHeader</code> to dynamically determine what bytes to use<br>
b. <code class="inline-code">NaluEventFooterUnpackerStage</code> (maybe can use below “simple dataproduct” case)<br>
i. Forms <code class="inline-code">NaluEventFooter</code> in the event</p>
<h2 id="2-provides-classes-derived-from-basestage-to-create-simple-data-products">2. Provides classes derived from BaseStage to create simple data products</h2>
<p>a. <code class="inline-code">NaluEventFormerStage</code><br>
i. Makes <code class="inline-code">NaluEvent</code> data product containing <code class="inline-code">NaluEventHeader</code>, <code class="inline-code">NaluEvent</code>, <code class="inline-code">NaluEventFooter</code><br>
b. <code class="inline-code">NaluWaveformFormer</code><br>
i. Makes <code class="inline-code">NaluWaveformCollection</code> from <code class="inline-code">NaluEvent</code></p>
<hr>
<h2 id="possible-improvements">Possible Improvements</h2>
<ol>
<li>“Simple dataproducts” (i.e. not dynamic, always aligned) can use a special child of ByteStreamProcessorStage<br>
a. Takes in dataproduct name and global endianness, that’s it.<br>
b. Uses ROOT’s collection meta data to fill in details.</li>
</ol>
<p>Goal-ish:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">{
  &quot;input_product_name&quot;: &quot;bytestream_bank_AD00&quot;,
  &quot;output_product_name&quot;: &quot;nalu_event_header&quot;,
  &quot;field_mappings&quot;: {
    &quot;event_header&quot;:         { &quot;offset&quot;: 0,  &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;event_info&quot;:           { &quot;offset&quot;: 2,  &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;event_index&quot;:          { &quot;offset&quot;: 4,  &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;event_reference_time&quot;: { &quot;offset&quot;: 8,  &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;packet_size&quot;:          { &quot;offset&quot;: 12, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;channel_mask&quot;:         { &quot;offset&quot;: 14, &quot;size&quot;: 8, &quot;endianness&quot;: &quot;little&quot; },
    &quot;num_windows&quot;:          { &quot;offset&quot;: 22, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;num_packets&quot;:          { &quot;offset&quot;: 24, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; }
  }
}



{
  &quot;input_bytestream_product&quot;: &quot;bytestream_bank_AD00&quot;,
  &quot;input_header_product&quot;: &quot;nalu_event_header&quot;,
  &quot;packet_header_mapping&quot;: {
    &quot;packet_header&quot;:       { &quot;offset&quot;: 0, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;packet_info&quot;:         { &quot;offset&quot;: 2, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;channel&quot;:             { &quot;offset&quot;: 4, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;trigger_time&quot;:        { &quot;offset&quot;: 6, &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;logical_position&quot;:    { &quot;offset&quot;: 10, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;window_position&quot;:     { &quot;offset&quot;: 12, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; }
  },
  &quot;packet_footer_mapping&quot;: {
    &quot;parser_index&quot;:        { &quot;offset&quot;: -8, &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;packet_footer&quot;:       { &quot;offset&quot;: -4, &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; }
  },
  &quot;trace_range&quot;: {
    &quot;offset&quot;: 14,
    &quot;length&quot;: 64   // in shorts, i.e., 2 bytes per sample
  },
  &quot;output_products&quot;: {
    &quot;packet_headers&quot;: &quot;nalu_packet_headers&quot;,
    &quot;packet_footers&quot;: &quot;nalu_packet_footers&quot;,
    &quot;packets&quot;: &quot;nalu_packets&quot;
  }
}</pre><pre class="hljs"><code>{
  &quot;input_product_name&quot;: &quot;bytestream_bank_AD00&quot;,
  &quot;output_product_name&quot;: &quot;nalu_event_header&quot;,
  &quot;field_mappings&quot;: {
    &quot;event_header&quot;:         { &quot;offset&quot;: 0,  &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;event_info&quot;:           { &quot;offset&quot;: 2,  &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;event_index&quot;:          { &quot;offset&quot;: 4,  &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;event_reference_time&quot;: { &quot;offset&quot;: 8,  &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;packet_size&quot;:          { &quot;offset&quot;: 12, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;channel_mask&quot;:         { &quot;offset&quot;: 14, &quot;size&quot;: 8, &quot;endianness&quot;: &quot;little&quot; },
    &quot;num_windows&quot;:          { &quot;offset&quot;: 22, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;num_packets&quot;:          { &quot;offset&quot;: 24, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; }
  }
}



{
  &quot;input_bytestream_product&quot;: &quot;bytestream_bank_AD00&quot;,
  &quot;input_header_product&quot;: &quot;nalu_event_header&quot;,
  &quot;packet_header_mapping&quot;: {
    &quot;packet_header&quot;:       { &quot;offset&quot;: 0, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;packet_info&quot;:         { &quot;offset&quot;: 2, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;channel&quot;:             { &quot;offset&quot;: 4, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;trigger_time&quot;:        { &quot;offset&quot;: 6, &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;logical_position&quot;:    { &quot;offset&quot;: 10, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; },
    &quot;window_position&quot;:     { &quot;offset&quot;: 12, &quot;size&quot;: 2, &quot;endianness&quot;: &quot;little&quot; }
  },
  &quot;packet_footer_mapping&quot;: {
    &quot;parser_index&quot;:        { &quot;offset&quot;: -8, &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; },
    &quot;packet_footer&quot;:       { &quot;offset&quot;: -4, &quot;size&quot;: 4, &quot;endianness&quot;: &quot;little&quot; }
  },
  &quot;trace_range&quot;: {
    &quot;offset&quot;: 14,
    &quot;length&quot;: 64   // in shorts, i.e., 2 bytes per sample
  },
  &quot;output_products&quot;: {
    &quot;packet_headers&quot;: &quot;nalu_packet_headers&quot;,
    &quot;packet_footers&quot;: &quot;nalu_packet_footers&quot;,
    &quot;packets&quot;: &quot;nalu_packets&quot;
  }
}</code></pre></div>
<hr>
<h2 id="23072025-1457">23/07/2025 14:57</h2>
<p>Made these new cells/edits</p>
<p>Cuts/Event extraction:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">channel_to_inspect = 1

Pseudotimes_Leading = []
LeadingEdgeSamples = []
Pseudotimes_Rising = []
RisingEdgeSamples = []
N_roll_overs = []
EventTimes = []
EventIndices = []

Nevents = tree.GetEntries()
print(&quot;Number of events:&quot;, Nevents)

last_ref_time = -1
N_rollovers = 0
T_rollover = 2**24

for entry in range(Nevents):
    tree.GetEntry(entry)

    # --- Rollover detection ---
    neh_vec = tree.nalu_event_headers
    if neh_vec.size() == 0:
        continue

    neh = neh_vec[0]
    event_time = neh.event_reference_time
    if event_time &lt; last_ref_time:
        N_rollovers += 1
    last_ref_time = event_time

    nw_vec = tree.nalu_waveforms
    for i_window in range(nw_vec.size()):
        wf = nw_vec[i_window]
        if wf.channel_num != channel_to_inspect:
            continue

        trace = np.array(wf.trace)
        if len(trace) &lt; 4:
            continue

        diff = np.diff(trace)

        # Leading edge
        leading_edge = np.argmin(diff)
        if leading_edge &lt; 1 or leading_edge + 1 &gt;= len(diff):
            continue

        numerator_lead = (-1)*diff[leading_edge] - (-1)*diff[leading_edge - 1]
        denominator_lead = (-1)*diff[leading_edge] - (-1)*diff[leading_edge + 1]
        if denominator_lead == 0:
            continue

        pt_lead = (2 / np.pi) * np.arctan(numerator_lead / denominator_lead)
        if not (0 &lt;= pt_lead &lt;= 1):
            continue

        # Rising edge
        rising_edge = np.argmax(diff)
        if rising_edge &lt; 1 or rising_edge + 1 &gt;= len(diff):
            continue

        numerator_rise = diff[rising_edge] - diff[rising_edge - 1]
        denominator_rise = diff[rising_edge] - diff[rising_edge + 1]
        if denominator_rise == 0:
            continue

        pt_rise = (2 / np.pi) * np.arctan(numerator_rise / denominator_rise)
        if not (0 &lt;= pt_rise &lt;= 1):
            continue

        # Append only if both edges valid
        Pseudotimes_Leading.append(pt_lead)
        LeadingEdgeSamples.append(leading_edge)
        Pseudotimes_Rising.append(pt_rise)
        RisingEdgeSamples.append(rising_edge)
        N_roll_overs.append(N_rollovers)
        EventTimes.append(event_time)
        EventIndices.append(entry)
</pre><pre class="hljs"><code>channel_to_inspect = 1

Pseudotimes_Leading = []
LeadingEdgeSamples = []
Pseudotimes_Rising = []
RisingEdgeSamples = []
N_roll_overs = []
EventTimes = []
EventIndices = []

Nevents = tree.GetEntries()
print(&quot;Number of events:&quot;, Nevents)

last_ref_time = -1
N_rollovers = 0
T_rollover = 2**24

for entry in range(Nevents):
    tree.GetEntry(entry)

    # --- Rollover detection ---
    neh_vec = tree.nalu_event_headers
    if neh_vec.size() == 0:
        continue

    neh = neh_vec[0]
    event_time = neh.event_reference_time
    if event_time &lt; last_ref_time:
        N_rollovers += 1
    last_ref_time = event_time

    nw_vec = tree.nalu_waveforms
    for i_window in range(nw_vec.size()):
        wf = nw_vec[i_window]
        if wf.channel_num != channel_to_inspect:
            continue

        trace = np.array(wf.trace)
        if len(trace) &lt; 4:
            continue

        diff = np.diff(trace)

        # Leading edge
        leading_edge = np.argmin(diff)
        if leading_edge &lt; 1 or leading_edge + 1 &gt;= len(diff):
            continue

        numerator_lead = (-1)*diff[leading_edge] - (-1)*diff[leading_edge - 1]
        denominator_lead = (-1)*diff[leading_edge] - (-1)*diff[leading_edge + 1]
        if denominator_lead == 0:
            continue

        pt_lead = (2 / np.pi) * np.arctan(numerator_lead / denominator_lead)
        if not (0 &lt;= pt_lead &lt;= 1):
            continue

        # Rising edge
        rising_edge = np.argmax(diff)
        if rising_edge &lt; 1 or rising_edge + 1 &gt;= len(diff):
            continue

        numerator_rise = diff[rising_edge] - diff[rising_edge - 1]
        denominator_rise = diff[rising_edge] - diff[rising_edge + 1]
        if denominator_rise == 0:
            continue

        pt_rise = (2 / np.pi) * np.arctan(numerator_rise / denominator_rise)
        if not (0 &lt;= pt_rise &lt;= 1):
            continue

        # Append only if both edges valid
        Pseudotimes_Leading.append(pt_lead)
        LeadingEdgeSamples.append(leading_edge)
        Pseudotimes_Rising.append(pt_rise)
        RisingEdgeSamples.append(rising_edge)
        N_roll_overs.append(N_rollovers)
        EventTimes.append(event_time)
        EventIndices.append(entry)
</code></pre></div>
<p>&quot;Suspicious&quot; event detector, marks events a difference of 10ns or more in the correct time</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">lead_diff_thresh = 10
trail_diff_thresh = 10

LeadLargeDiffPairs = []
TrailLargeDiffPairs = []

lead_diff = np.abs(np.diff(corrected_lead_t))
trail_diff = np.abs(np.diff(corrected_trail_t))

for i, d in enumerate(lead_diff):
    if d &gt; lead_diff_thresh and i+1 &lt; len(EventIndices):
        LeadLargeDiffPairs.append((EventIndices[i], EventIndices[i+1]))

for i, d in enumerate(trail_diff):
    if d &gt; trail_diff_thresh and i+1 &lt; len(EventIndices):
        TrailLargeDiffPairs.append((EventIndices[i], EventIndices[i+1]))

print(&quot;# of Lead suspicious event pairs:&quot;, len(LeadLargeDiffPairs))
print(&quot;# of Trail suspicious event pairs:&quot;, len(TrailLargeDiffPairs))
</pre><pre class="hljs"><code>lead_diff_thresh = <span class="hljs-number">10</span>
trail_diff_thresh = <span class="hljs-number">10</span>

LeadLargeDiffPairs = <span class="hljs-selector-attr">[]</span>
TrailLargeDiffPairs = <span class="hljs-selector-attr">[]</span>

lead_diff = np<span class="hljs-selector-class">.abs</span>(np<span class="hljs-selector-class">.diff</span>(corrected_lead_t))
trail_diff = np<span class="hljs-selector-class">.abs</span>(np<span class="hljs-selector-class">.diff</span>(corrected_trail_t))

<span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lead_diff):
    <span class="hljs-keyword">if</span> d &gt; lead_diff_thresh and i+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(EventIndices):
        LeadLargeDiffPairs<span class="hljs-selector-class">.append</span>((EventIndices<span class="hljs-selector-attr">[i]</span>, EventIndices<span class="hljs-selector-attr">[i+1]</span>))

<span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trail_diff):
    <span class="hljs-keyword">if</span> d &gt; trail_diff_thresh and i+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(EventIndices):
        TrailLargeDiffPairs<span class="hljs-selector-class">.append</span>((EventIndices<span class="hljs-selector-attr">[i]</span>, EventIndices<span class="hljs-selector-attr">[i+1]</span>))

<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;# of Lead suspicious event pairs:&quot;</span>, len(LeadLargeDiffPairs)</span></span>)
<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;# of Trail suspicious event pairs:&quot;</span>, len(TrailLargeDiffPairs)</span></span>)
</code></pre></div>
<p>Plots for leading and trailing cases, (they're probably the same set, I didn't bother checking though)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># Pick an index into the suspicious lead pair list
i = 1  # change this index to view different pairs

if i &lt; len(LeadLargeDiffPairs):
    entry1, entry2 = LeadLargeDiffPairs[i]

    fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

    for ax_idx, entry_idx in enumerate([entry1, entry2]):
        tree.GetEntry(entry_idx)
        ax = axes[ax_idx]
        try:
            corrected_idx = EventIndices.index(entry_idx)
            corrected_time = corrected_lead_t[corrected_idx]

            # Build a mapping: channel_num → list of window_positions
            chan_to_windows = {}
            for j in range(tree.nalu_packet_headers.size()):
                ch = tree.nalu_packet_headers[j].channel
                wp = tree.nalu_packet_headers[j].window_position
                if ch not in chan_to_windows:
                    chan_to_windows[ch] = set()
                chan_to_windows[ch].add(wp)

            for wf in tree.nalu_waveforms:
                ax.plot(wf.trace, label=f&quot;Ch{wf.channel_num}&quot;)

            ax.set_title(f&quot;Lead Event {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            ax.set_ylabel(&quot;ADC&quot;)
            ax.legend()
            ax.grid(True)

            # Print table of window positions
            print(f&quot;\nEvent {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            print(f&quot;{'Channel':&lt;10}Window Positions&quot;)
            print(&quot;-&quot; * 30)
            for ch in sorted(chan_to_windows.keys()):
                windows = sorted(chan_to_windows[ch])
                print(f&quot;{ch:&lt;10}{windows}&quot;)

        except ValueError:
            ax.set_title(f&quot;Event {entry_idx} not in EventIndices&quot;)
            ax.grid(True)

    axes[-1].set_xlabel(&quot;Sample Index&quot;)
    fig.suptitle(f&quot;Suspicious Lead Pair: Events {entry1}, {entry2}&quot;, fontsize=14)
    plt.tight_layout()
    plt.show()
else:
    print(&quot;Index out of range&quot;)
</pre><pre class="hljs"><code># Pick an index into the suspicious lead pair list
i = 1  # change this index to view different pairs

if i &lt; len(LeadLargeDiffPairs):
    entry1, entry2 = LeadLargeDiffPairs[i]

    fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

    for ax_idx, entry_idx in enumerate([entry1, entry2]):
        tree.GetEntry(entry_idx)
        ax = axes[ax_idx]
        try:
            corrected_idx = EventIndices.index(entry_idx)
            corrected_time = corrected_lead_t[corrected_idx]

            # Build a mapping: channel_num → list of window_positions
            chan_to_windows = {}
            for j in range(tree.nalu_packet_headers.size()):
                ch = tree.nalu_packet_headers[j].channel
                wp = tree.nalu_packet_headers[j].window_position
                if ch not in chan_to_windows:
                    chan_to_windows[ch] = set()
                chan_to_windows[ch].add(wp)

            for wf in tree.nalu_waveforms:
                ax.plot(wf.trace, label=f&quot;Ch{wf.channel_num}&quot;)

            ax.set_title(f&quot;Lead Event {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            ax.set_ylabel(&quot;ADC&quot;)
            ax.legend()
            ax.grid(True)

            # Print table of window positions
            print(f&quot;\nEvent {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            print(f&quot;{'Channel':&lt;10}Window Positions&quot;)
            print(&quot;-&quot; * 30)
            for ch in sorted(chan_to_windows.keys()):
                windows = sorted(chan_to_windows[ch])
                print(f&quot;{ch:&lt;10}{windows}&quot;)

        except ValueError:
            ax.set_title(f&quot;Event {entry_idx} not in EventIndices&quot;)
            ax.grid(True)

    axes[-1].set_xlabel(&quot;Sample Index&quot;)
    fig.suptitle(f&quot;Suspicious Lead Pair: Events {entry1}, {entry2}&quot;, fontsize=14)
    plt.tight_layout()
    plt.show()
else:
    print(&quot;Index out of range&quot;)
</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># Pick an index into the suspicious trail pair list
i = 1  # change this index to view different pairs

if i &lt; len(TrailLargeDiffPairs):
    entry1, entry2 = TrailLargeDiffPairs[i]

    fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

    for ax_idx, entry_idx in enumerate([entry1, entry2]):
        tree.GetEntry(entry_idx)
        ax = axes[ax_idx]
        try:
            corrected_idx = EventIndices.index(entry_idx)
            corrected_time = corrected_trail_t[corrected_idx]

            # Build a mapping: channel_num → set of window_positions
            chan_to_windows = {}
            for j in range(tree.nalu_packet_headers.size()):
                ch = tree.nalu_packet_headers[j].channel
                wp = tree.nalu_packet_headers[j].window_position
                if ch not in chan_to_windows:
                    chan_to_windows[ch] = set()
                chan_to_windows[ch].add(wp)

            for wf in tree.nalu_waveforms:
                ax.plot(wf.trace, label=f&quot;Ch{wf.channel_num}&quot;)

            ax.set_title(f&quot;Trail Event {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            ax.set_ylabel(&quot;ADC&quot;)
            ax.legend()
            ax.grid(True)

            # Print table of window positions per channel
            print(f&quot;\nEvent {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            print(f&quot;{'Channel':&lt;10}Window Positions&quot;)
            print(&quot;-&quot; * 30)
            for ch in sorted(chan_to_windows.keys()):
                windows = sorted(chan_to_windows[ch])
                print(f&quot;{ch:&lt;10}{windows}&quot;)

        except ValueError:
            ax.set_title(f&quot;Event {entry_idx} not in EventIndices&quot;)
            ax.grid(True)

    axes[-1].set_xlabel(&quot;Sample Index&quot;)
    fig.suptitle(f&quot;Suspicious Trail Pair: Events {entry1}, {entry2}&quot;, fontsize=14)
    plt.tight_layout()
    plt.show()
else:
    print(&quot;Index out of range&quot;)
</pre><pre class="hljs"><code># Pick an index into the suspicious trail pair list
i = 1  # change this index to view different pairs

if i &lt; len(TrailLargeDiffPairs):
    entry1, entry2 = TrailLargeDiffPairs[i]

    fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

    for ax_idx, entry_idx in enumerate([entry1, entry2]):
        tree.GetEntry(entry_idx)
        ax = axes[ax_idx]
        try:
            corrected_idx = EventIndices.index(entry_idx)
            corrected_time = corrected_trail_t[corrected_idx]

            # Build a mapping: channel_num → set of window_positions
            chan_to_windows = {}
            for j in range(tree.nalu_packet_headers.size()):
                ch = tree.nalu_packet_headers[j].channel
                wp = tree.nalu_packet_headers[j].window_position
                if ch not in chan_to_windows:
                    chan_to_windows[ch] = set()
                chan_to_windows[ch].add(wp)

            for wf in tree.nalu_waveforms:
                ax.plot(wf.trace, label=f&quot;Ch{wf.channel_num}&quot;)

            ax.set_title(f&quot;Trail Event {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            ax.set_ylabel(&quot;ADC&quot;)
            ax.legend()
            ax.grid(True)

            # Print table of window positions per channel
            print(f&quot;\nEvent {entry_idx} | Corrected Time = {corrected_time:.2f}&quot;)
            print(f&quot;{'Channel':&lt;10}Window Positions&quot;)
            print(&quot;-&quot; * 30)
            for ch in sorted(chan_to_windows.keys()):
                windows = sorted(chan_to_windows[ch])
                print(f&quot;{ch:&lt;10}{windows}&quot;)

        except ValueError:
            ax.set_title(f&quot;Event {entry_idx} not in EventIndices&quot;)
            ax.grid(True)

    axes[-1].set_xlabel(&quot;Sample Index&quot;)
    fig.suptitle(f&quot;Suspicious Trail Pair: Events {entry1}, {entry2}&quot;, fontsize=14)
    plt.tight_layout()
    plt.show()
else:
    print(&quot;Index out of range&quot;)
</code></pre></div>
<hr>
<h2 id="23072025-1500">23/07/2025 15:00</h2>
<h3 id="case-1-hdsoc-strangely-aligning-samples-i-dont-know-whats-going-on-here">Case 1. HDSoC strangely aligning samples (I don't know what's going on here)</h3>
<p><strong>Event 10</strong> | Corrected Time = 46.79</p>
<div class="joplin-table-wrapper">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Window Positions</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[41, 42, 43, 44]</td>
</tr>
<tr>
<td>1</td>
<td>[41, 42, 43, 44]</td>
</tr>
<tr>
<td>2</td>
<td>[41, 42, 43, 44]</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Event 11</strong> | Corrected Time = 16.48</p>
<div class="joplin-table-wrapper">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Window Positions</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[44, 45, 46, 47]</td>
</tr>
<tr>
<td>1</td>
<td>[44, 45, 46, 47]</td>
</tr>
<tr>
<td>2</td>
<td>[43, 44, 45, 46]</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../_resources/66adcea1a0e34c02bd522343966ce133.png" alt="c419d04a0ce76b0974fd1e6ad0c26512.png"></p>
<h3 id="case-2-events-getting-split-up-this-one-is-a-bug-in-my-collector">Case 2. Events getting split up (this one is a bug in my collector)</h3>
<p><strong>Event 19</strong> | Corrected Time = 29.15</p>
<div class="joplin-table-wrapper">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Window Positions</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[58, 59]</td>
</tr>
<tr>
<td>1</td>
<td>[58, 59]</td>
</tr>
<tr>
<td>2</td>
<td>[58]</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Event 20</strong> | Corrected Time = 56.21</p>
<div class="joplin-table-wrapper">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Window Positions</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[60, 61]</td>
</tr>
<tr>
<td>1</td>
<td>[60, 61]</td>
</tr>
<tr>
<td>2</td>
<td>[59, 60, 61]</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../_resources/4c53cde123e0450ba453f253daa8f6c7.png" alt="f0de253cb81085c46d4285f765efe8bf.png"></p>
<h3 id="case-3-controlgood-event">Case 3. Control/Good Event</h3>
<p><strong>Event 0</strong> | Corrected Time = 29.25</p>
<div class="joplin-table-wrapper">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Window Positions</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[21, 22, 23, 24]</td>
</tr>
<tr>
<td>1</td>
<td>[21, 22, 23, 24]</td>
</tr>
<tr>
<td>2</td>
<td>[21, 22, 23, 24]</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Event 1</strong> | Corrected Time = 30.94</p>
<div class="joplin-table-wrapper">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Window Positions</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[23, 24, 25, 26]</td>
</tr>
<tr>
<td>1</td>
<td>[23, 24, 25, 26]</td>
</tr>
<tr>
<td>2</td>
<td>[23, 24, 25, 26]</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../_resources/94dbb143e93e490cbba2d4824f6a25df.png" alt="2a2ff9a2dd65046aff10473a6ebd890c.png"></p>
<hr>
<h2 id="23072025-1507">23/07/2025 15:07</h2>
<p>I added three cuts:</p>
<ol>
<li>Each channel has exactly 4 windows.</li>
<li>All channels share the same window positions.</li>
<li>Those window positions form a consecutive sequence.</li>
</ol>
<p>And I rewrote the &quot;extraction&quot; section to have each cut toggle-able</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">channel_to_inspect = 1
expected_num_windows = 4
T_rollover = 2**24
min_trace_length = 4

# --- Cut switches ---
CUT_SKIP_IF_NO_HEADER           = True
CUT_ENFORCE_WINDOW_COUNT        = True
CUT_ENFORCE_WINDOW_MATCH        = True
CUT_ENFORCE_WINDOW_SEQUENTIAL   = True
CUT_REQUIRE_MIN_TRACE_LENGTH    = True
CUT_REQUIRE_VALID_EDGES         = True
CUT_REQUIRE_VALID_PSEUDOTIMES   = True

# --- Data accumulators ---
Pseudotimes_Leading = []
LeadingEdgeSamples = []
Pseudotimes_Rising = []
RisingEdgeSamples = []
N_roll_overs = []
EventTimes = []
EventIndices = []

Nevents = tree.GetEntries()
print(&quot;Number of events:&quot;, Nevents)

last_ref_time = -1
N_rollovers = 0

for entry in range(Nevents):
    tree.GetEntry(entry)

    # --- Rollover detection ---
    neh_vec = tree.nalu_event_headers
    if CUT_SKIP_IF_NO_HEADER and neh_vec.size() == 0:
        continue

    neh = neh_vec[0]
    event_time = neh.event_reference_time
    if event_time &lt; last_ref_time:
        N_rollovers += 1
    last_ref_time = event_time

    # --- CUTS: Packet header window structure ---
    channel_window_map = {}
    for i in range(tree.nalu_packet_headers.size()):
        ph = tree.nalu_packet_headers[i]
        ch = ph.channel
        wp = ph.window_position
        if ch not in channel_window_map:
            channel_window_map[ch] = set()
        channel_window_map[ch].add(wp)

    if CUT_ENFORCE_WINDOW_COUNT:
        if any(len(wps) != expected_num_windows for wps in channel_window_map.values()):
            continue

    if CUT_ENFORCE_WINDOW_MATCH:
        window_sets = list(channel_window_map.values())
        if any(wps != window_sets[0] for wps in window_sets[1:]):
            continue

    if CUT_ENFORCE_WINDOW_SEQUENTIAL:
        sorted_wps = sorted(window_sets[0])
        if sorted_wps != list(range(sorted_wps[0], sorted_wps[0] + expected_num_windows)):
            continue

    # --- Waveform Processing ---
    nw_vec = tree.nalu_waveforms
    for i_window in range(nw_vec.size()):
        wf = nw_vec[i_window]
        if wf.channel_num != channel_to_inspect:
            continue

        trace = np.array(wf.trace)
        if CUT_REQUIRE_MIN_TRACE_LENGTH and len(trace) &lt; min_trace_length:
            continue

        diff = np.diff(trace)

        # --- Leading Edge ---
        leading_edge = np.argmin(diff)
        if CUT_REQUIRE_VALID_EDGES and (leading_edge &lt; 1 or leading_edge + 1 &gt;= len(diff)):
            continue

        numerator_lead = diff[leading_edge - 1] - diff[leading_edge]
        denominator_lead = diff[leading_edge + 1] - diff[leading_edge]
        if CUT_REQUIRE_VALID_PSEUDOTIMES and denominator_lead == 0:
            continue

        pt_lead = (2 / np.pi) * np.arctan(numerator_lead / denominator_lead)
        if CUT_REQUIRE_VALID_PSEUDOTIMES and not (0 &lt;= pt_lead &lt;= 1):
            continue

        # --- Rising Edge ---
        rising_edge = np.argmax(diff)
        if CUT_REQUIRE_VALID_EDGES and (rising_edge &lt; 1 or rising_edge + 1 &gt;= len(diff)):
            continue

        numerator_rise = diff[rising_edge] - diff[rising_edge - 1]
        denominator_rise = diff[rising_edge] - diff[rising_edge + 1]
        if CUT_REQUIRE_VALID_PSEUDOTIMES and denominator_rise == 0:
            continue

        pt_rise = (2 / np.pi) * np.arctan(numerator_rise / denominator_rise)
        if CUT_REQUIRE_VALID_PSEUDOTIMES and not (0 &lt;= pt_rise &lt;= 1):
            continue

        # --- Store results ---
        Pseudotimes_Leading.append(pt_lead)
        LeadingEdgeSamples.append(leading_edge)
        Pseudotimes_Rising.append(pt_rise)
        RisingEdgeSamples.append(rising_edge)
        N_roll_overs.append(N_rollovers)
        EventTimes.append(event_time)
        EventIndices.append(entry)</pre><pre class="hljs"><code>channel_to_inspect = 1
expected_num_windows = 4
T_rollover = 2**24
min_trace_length = 4

# --- Cut switches ---
CUT_SKIP_IF_NO_HEADER           = True
CUT_ENFORCE_WINDOW_COUNT        = True
CUT_ENFORCE_WINDOW_MATCH        = True
CUT_ENFORCE_WINDOW_SEQUENTIAL   = True
CUT_REQUIRE_MIN_TRACE_LENGTH    = True
CUT_REQUIRE_VALID_EDGES         = True
CUT_REQUIRE_VALID_PSEUDOTIMES   = True

# --- Data accumulators ---
Pseudotimes_Leading = []
LeadingEdgeSamples = []
Pseudotimes_Rising = []
RisingEdgeSamples = []
N_roll_overs = []
EventTimes = []
EventIndices = []

Nevents = tree.GetEntries()
print(&quot;Number of events:&quot;, Nevents)

last_ref_time = -1
N_rollovers = 0

for entry in range(Nevents):
    tree.GetEntry(entry)

    # --- Rollover detection ---
    neh_vec = tree.nalu_event_headers
    if CUT_SKIP_IF_NO_HEADER and neh_vec.size() == 0:
        continue

    neh = neh_vec[0]
    event_time = neh.event_reference_time
    if event_time &lt; last_ref_time:
        N_rollovers += 1
    last_ref_time = event_time

    # --- CUTS: Packet header window structure ---
    channel_window_map = {}
    for i in range(tree.nalu_packet_headers.size()):
        ph = tree.nalu_packet_headers[i]
        ch = ph.channel
        wp = ph.window_position
        if ch not in channel_window_map:
            channel_window_map[ch] = set()
        channel_window_map[ch].add(wp)

    if CUT_ENFORCE_WINDOW_COUNT:
        if any(len(wps) != expected_num_windows for wps in channel_window_map.values()):
            continue

    if CUT_ENFORCE_WINDOW_MATCH:
        window_sets = list(channel_window_map.values())
        if any(wps != window_sets[0] for wps in window_sets[1:]):
            continue

    if CUT_ENFORCE_WINDOW_SEQUENTIAL:
        sorted_wps = sorted(window_sets[0])
        if sorted_wps != list(range(sorted_wps[0], sorted_wps[0] + expected_num_windows)):
            continue

    # --- Waveform Processing ---
    nw_vec = tree.nalu_waveforms
    for i_window in range(nw_vec.size()):
        wf = nw_vec[i_window]
        if wf.channel_num != channel_to_inspect:
            continue

        trace = np.array(wf.trace)
        if CUT_REQUIRE_MIN_TRACE_LENGTH and len(trace) &lt; min_trace_length:
            continue

        diff = np.diff(trace)

        # --- Leading Edge ---
        leading_edge = np.argmin(diff)
        if CUT_REQUIRE_VALID_EDGES and (leading_edge &lt; 1 or leading_edge + 1 &gt;= len(diff)):
            continue

        numerator_lead = diff[leading_edge - 1] - diff[leading_edge]
        denominator_lead = diff[leading_edge + 1] - diff[leading_edge]
        if CUT_REQUIRE_VALID_PSEUDOTIMES and denominator_lead == 0:
            continue

        pt_lead = (2 / np.pi) * np.arctan(numerator_lead / denominator_lead)
        if CUT_REQUIRE_VALID_PSEUDOTIMES and not (0 &lt;= pt_lead &lt;= 1):
            continue

        # --- Rising Edge ---
        rising_edge = np.argmax(diff)
        if CUT_REQUIRE_VALID_EDGES and (rising_edge &lt; 1 or rising_edge + 1 &gt;= len(diff)):
            continue

        numerator_rise = diff[rising_edge] - diff[rising_edge - 1]
        denominator_rise = diff[rising_edge] - diff[rising_edge + 1]
        if CUT_REQUIRE_VALID_PSEUDOTIMES and denominator_rise == 0:
            continue

        pt_rise = (2 / np.pi) * np.arctan(numerator_rise / denominator_rise)
        if CUT_REQUIRE_VALID_PSEUDOTIMES and not (0 &lt;= pt_rise &lt;= 1):
            continue

        # --- Store results ---
        Pseudotimes_Leading.append(pt_lead)
        LeadingEdgeSamples.append(leading_edge)
        Pseudotimes_Rising.append(pt_rise)
        RisingEdgeSamples.append(rising_edge)
        N_roll_overs.append(N_rollovers)
        EventTimes.append(event_time)
        EventIndices.append(entry)</code></pre></div>
<p>The result seems expected, we shrink the correct time</p>
<p><img src="../_resources/a4fc3cdf7d884b85bc56b10390505262.png" alt="9628efe89eeddea06724823a3e10a7c2.png"></p>
<p>Maybe this plot is misleading/incorrec though(?). The true time still seems to look not good:<br>
<img src="../_resources/0a581ecffcdc4932ac444825421c6036.png" alt="febc7f9d8ef2e6cb08968794aff85b38.png"></p>
<p>We also see a large number of suspicious events:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># of Lead suspicious event pairs: 7532
# of Trail suspicious event pairs: 7532</pre><pre class="hljs"><code><span class="hljs-comment"># of Lead suspicious event pairs: 7532</span>
<span class="hljs-comment"># of Trail suspicious event pairs: 7532</span></code></pre></div>
<p>This is less than previously though by a factor of ~2:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># of Lead suspicious event pairs: 17053
# of Trail suspicious event pairs: 17053</pre><pre class="hljs"><code><span class="hljs-comment"># of Lead suspicious event pairs: 17053</span>
<span class="hljs-comment"># of Trail suspicious event pairs: 17053</span></code></pre></div>
<p>That all look like (from the few I checked):</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Event 30 | Corrected Time = 47.37
Channel   Window Positions
------------------------------
0         [16, 17, 18, 19]
1         [16, 17, 18, 19]
2         [16, 17, 18, 19]

Event 32 | Corrected Time = 18.93
Channel   Window Positions
------------------------------
0         [21, 22, 23, 24]
1         [21, 22, 23, 24]
2         [21, 22, 23, 24]</pre><pre class="hljs"><code>Event 30 | Corrected Time = 47.37
<span class="hljs-section">Channel   Window Positions
------------------------------</span>
0         [16, 17, 18, 19]
1         [16, 17, 18, 19]
2         [16, 17, 18, 19]

Event 32 | Corrected Time = 18.93
<span class="hljs-section">Channel   Window Positions
------------------------------</span>
0         [21, 22, 23, 24]
1         [21, 22, 23, 24]
2         [21, 22, 23, 24]</code></pre></div>
<p><img src="../_resources/029c68e832934a608027c13f9034fcac.png" alt="a1e8fca871e6ae8e9560df1214fe7238.png"></p>
<p>We still end up cutting out a lot of bad events. Though cut &quot;2. All channels share the same window positions&quot; doesn't seems to be working as I'd hoped. It seems the HDSoC has some strange decision making on how it decides to place the pulse trigger.</p>
<hr>
<h2 id="24072025-0256">24/07/2025 02:56</h2>
<h1 id="todo-nalu-unpacking-pipeline-next-steps">TODO – Nalu Unpacking Pipeline (Next Steps)</h1>
<h2 id="eight_spoked_asterisk-pipeline-stages-to-implement">✳️ Pipeline Stages to Implement</h2>
<h3 id="1-nalueventheaderunpackerstage">1. <code class="inline-code">NaluEventHeaderUnpackerStage</code></h3>
<ul>
<li>Reads from a <code class="inline-code">ByteStream</code></li>
<li>Parses and constructs a <code class="inline-code">NaluEventHeader</code> struct</li>
<li>Publishes: <code class="inline-code">PipelineDataProduct&lt;NaluEventHeader&gt;</code></li>
</ul>
<h3 id="2-nalupacketcollectionunpackerstage">2. <code class="inline-code">NaluPacketCollectionUnpackerStage</code></h3>
<ul>
<li>Repeatedly parses triplets of:
<ul>
<li><code class="inline-code">NaluPacketHeader</code></li>
<li><code class="inline-code">NaluPacketPayload</code></li>
<li><code class="inline-code">NaluPacketFooter</code></li>
</ul>
</li>
<li>Constructs <code class="inline-code">NaluPacket</code> objects from triplets</li>
<li>Publishes: <code class="inline-code">PipelineDataProduct&lt;NaluPacketCollection&gt;</code></li>
</ul>
<h3 id="3-nalueventfooterunpackerstage">3. <code class="inline-code">NaluEventFooterUnpackerStage</code></h3>
<ul>
<li>Parses a single <code class="inline-code">NaluEventFooter</code> struct</li>
<li>Publishes: <code class="inline-code">PipelineDataProduct&lt;NaluEventFooter&gt;</code></li>
</ul>
<hr>
<h2 id="gear-endianness-handling-strategy">⚙️ Endianness Handling Strategy</h2>
<ul>
<li>Binary data fields may require per-member endian correction.</li>
<li>A <strong>global struct-level toggle</strong> is insufficient.</li>
<li>Design a <strong>general helper utility</strong> to:
<ul>
<li>Define per-field endianness policies (e.g., via JSON config)</li>
<li>Apply byte-swaps in a centralized manner</li>
<li>Keep <code class="inline-code">memcpy</code>-based unpacking fast and readable</li>
</ul>
</li>
<li>Possible approach:
<ul>
<li>Table-driven field mapping per struct</li>
<li>Use helper functions: <code class="inline-code">read_u16_be(...)</code>, etc.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="arrows_counterclockwise-refactoring-plan">🔄 Refactoring Plan</h2>
<h3 id="move-bytestreamprocessorstage">Move <code class="inline-code">ByteStreamProcessorStage</code>:</h3>
<ul>
<li><strong>From</strong>: <code class="inline-code">unpacker_stages_nalu</code></li>
<li><strong>To</strong>: <code class="inline-code">unpacker_stages_core</code></li>
<li>Rationale:
<ul>
<li>It is generic infrastructure</li>
<li>Avoids polluting NALU-specific logic with general-purpose dependencies</li>
</ul>
</li>
</ul>
<hr>
<h2 id="white_check_mark-notes">✅ Notes</h2>
<ul>
<li>Avoid ROOT reflection during unpacking.</li>
<li>Stick to POD structs with explicit unpackers.</li>
<li>Config can drive unpacker behavior (loop count, mapping), but unpacker must be written per struct.</li>
</ul>
<hr>
<h2 id="24072025-1520">24/07/2025 15:20</h2>
<p>I'm noticing my cuts actually seem to clean up basically all the noise:<br>
<img src="../_resources/edf43dbe96f84fd4bd39802a70de7c46.png" alt="20324dd27d819f198225f9959be53a64.png"></p>
<p>The confusion last time was I was not displaying negative differences on the time difference histogram, these are were all our outlier are<br>
<img src="../_resources/d76600bcdd2b4bf59065d1817865cc36.png" alt="a4f2e0e307d0077d5f49cf118db23c25.png"></p>
<p>However this is not symmetric, which means there MUST be a systematic effect. From our previous plots:<br>
<img src="../_resources/029c68e832934a608027c13f9034fcac.png" alt="a1e8fca871e6ae8e9560df1214fe7238.png"><br>
we saw skips backwards. From this, I hypothesize we must have some drift where once we reach the end of a window, the HDSoC moves the pulse back to the start of the window. To check that, we can look at a sequence of many events<br>
<img src="../_resources/a510cd790f9e4433af9f0a6489e58785.png" alt="01ec263007229926a1bbb5add6d6c277.png"></p>
<p>Ignore the poor plot quality and the events that are bugged/don't pass our cuts (15, 19, 20, 21 and 31 all get cut). You can see a noticeable signal drifft. Once the signal drifts too far, it &quot;jumps back&quot;. This has to do with the digitzation settings. The HDSoC somehow aligns things such that there is a fixed number of windows ahead of and behind the pulse. As a result, if a pulse is drifting it will occassionally &quot;jump back&quot; a full window (corresponding to 32 ns). I'm not sure how to account for this, Tim and/or Sean's input mya be helpful here.</p>
<p>The spikes in the true time differences correspond to dropped events<br>
<img src="../_resources/84d377a2ee1c493ebcb9c26b20ccdff1.png" alt="5fbc6a0576010c0ade783a0ca0ee0369.png"></p>
<p>Each spike is a multiple (1, 2 or 3) of the first spike. This indicates dropped events. This is expected from our cuts before. Sometimes we're taking the time difference between event index 14 and 16 because we cut event 15, for example. We can instead only consider the true time difference of sequential events only to get a better image to determine timing resolution on:</p>
<p><img src="../_resources/76cfd3df15be4bd58c1c6657c373c247.png" alt="ab271bc4f799cb91028ebadd6ac92d0d.png"><br>
<img src="../_resources/cf56eaae84084613b2feedee172f62d4.png" alt="ef5c435aabad1a4c71174451d75fe33c.png"></p>
<p>You can see the &quot;back hump,&quot; I'm not sure what's causing that.Regardless of the hump, the timing resolution seems to be about 0.13 ns from my analysis, which seems reasonable(?).</p>
<p>As a side not you can also cut out all the negative time diffs in the corrected time differences to get a better idea of the distribution:<br>
<img src="../_resources/542fe6895e90460ca26be76d0b3fd0c6.png" alt="554c4141deecef03c6593cb811d5ddb5.png"></p>
<p>Some of the relevant plotting code:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">corrected_time_l_diff = np.diff(corrected_lead_t)
corrected_time_t_diff = np.diff(corrected_trail_t)

bins = int(np.sqrt(len(corrected_time_t_diff)))
plt.figure(figsize=(10, 5))
plt.hist(corrected_time_l_diff, bins=bins, alpha=0.3, label=&quot;Leading Edge&quot;, edgecolor='blue')
plt.hist(corrected_time_t_diff, bins=bins, alpha=0.3, label=&quot;Trailing Edge&quot;, edgecolor='orange')

plt.xlabel(&quot;Corrected time difference&quot;)
plt.ylabel(&quot;Frequency&quot;)
plt.yscale(&quot;log&quot;)
plt.title(&quot;Corrected Time Difference Histogram (Log Scale)&quot;)
plt.legend(loc='upper right')
plt.grid(True)
plt.show()
</pre><pre class="hljs"><code>corrected_time_l_diff = np.diff(corrected_lead_t)
corrected_time_t_diff = np.diff(corrected_trail_t)

bins = int(np.sqrt(len(corrected_time_t_diff)))
plt.figure(figsize=(10, 5))
plt.hist(corrected_time_l_diff, <span class="hljs-attribute">bins</span>=bins, <span class="hljs-attribute">alpha</span>=0.3, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;Leading Edge&quot;</span>, <span class="hljs-attribute">edgecolor</span>=<span class="hljs-string">&#x27;blue&#x27;</span>)
plt.hist(corrected_time_t_diff, <span class="hljs-attribute">bins</span>=bins, <span class="hljs-attribute">alpha</span>=0.3, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;Trailing Edge&quot;</span>, <span class="hljs-attribute">edgecolor</span>=<span class="hljs-string">&#x27;orange&#x27;</span>)

plt.xlabel(<span class="hljs-string">&quot;Corrected time difference&quot;</span>)
plt.ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)
plt.yscale(<span class="hljs-string">&quot;log&quot;</span>)
plt.title(<span class="hljs-string">&quot;Corrected Time Difference Histogram (Log Scale)&quot;</span>)
plt.legend(<span class="hljs-attribute">loc</span>=<span class="hljs-string">&#x27;upper right&#x27;</span>)
plt.grid(<span class="hljs-literal">True</span>)
plt.show()
</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># --- Cut switch ---
CUT_NEGATIVE_CORRECTED_DIFFS = True

# Compute diffs
corrected_time_l_diff = np.diff(corrected_lead_t)
corrected_time_t_diff = np.diff(corrected_trail_t)

# Apply post-histogram cuts
cut_mask_l = corrected_time_l_diff &gt; 0 if CUT_NEGATIVE_CORRECTED_DIFFS else np.ones_like(corrected_time_l_diff, dtype=bool)
cut_mask_t = corrected_time_t_diff &gt; 0 if CUT_NEGATIVE_CORRECTED_DIFFS else np.ones_like(corrected_time_t_diff, dtype=bool)

corrected_time_l_diff_cut = corrected_time_l_diff[cut_mask_l]
corrected_time_t_diff_cut = corrected_time_t_diff[cut_mask_t]

print(f&quot;Lead diffs kept: {len(corrected_time_l_diff_cut)} / {len(corrected_time_l_diff)}&quot;)
print(f&quot;Trail diffs kept: {len(corrected_time_t_diff_cut)} / {len(corrected_time_t_diff)}&quot;)

# --- Plot ---
bins = int(np.sqrt(len(corrected_time_l_diff_cut)))
plt.figure(figsize=(10, 5))
plt.hist(corrected_time_l_diff_cut, bins=bins, alpha=0.3, label=&quot;Leading Edge&quot;, edgecolor='blue')
plt.hist(corrected_time_t_diff_cut, bins=bins, alpha=0.3, label=&quot;Trailing Edge&quot;, edgecolor='orange')

plt.xlabel(&quot;Corrected time difference&quot;)
plt.ylabel(&quot;Frequency&quot;)
plt.yscale(&quot;log&quot;)
plt.title(&quot;Corrected Time Difference Histogram (Log Scale)&quot;)
plt.legend(loc='upper right')
plt.grid(True)
plt.show()
</pre><pre class="hljs"><code># --- Cut switch ---
CUT_NEGATIVE_CORRECTED_DIFFS = True

# Compute diffs
corrected_time_l_diff = np.diff(corrected_lead_t)
corrected_time_t_diff = np.diff(corrected_trail_t)

# Apply post-histogram cuts
cut_mask_l = corrected_time_l_diff &gt; 0 if CUT_NEGATIVE_CORRECTED_DIFFS else np.ones_like(corrected_time_l_diff, dtype=bool)
cut_mask_t = corrected_time_t_diff &gt; 0 if CUT_NEGATIVE_CORRECTED_DIFFS else np.ones_like(corrected_time_t_diff, dtype=bool)

corrected_time_l_diff_cut = corrected_time_l_diff[cut_mask_l]
corrected_time_t_diff_cut = corrected_time_t_diff[cut_mask_t]

print(f&quot;Lead diffs kept: {len(corrected_time_l_diff_cut)} / {len(corrected_time_l_diff)}&quot;)
print(f&quot;Trail diffs kept: {len(corrected_time_t_diff_cut)} / {len(corrected_time_t_diff)}&quot;)

# --- Plot ---
bins = int(np.sqrt(len(corrected_time_l_diff_cut)))
plt.figure(figsize=(10, 5))
plt.hist(corrected_time_l_diff_cut, bins=bins, alpha=0.3, label=&quot;Leading Edge&quot;, edgecolor='blue')
plt.hist(corrected_time_t_diff_cut, bins=bins, alpha=0.3, label=&quot;Trailing Edge&quot;, edgecolor='orange')

plt.xlabel(&quot;Corrected time difference&quot;)
plt.ylabel(&quot;Frequency&quot;)
plt.yscale(&quot;log&quot;)
plt.title(&quot;Corrected Time Difference Histogram (Log Scale)&quot;)
plt.legend(loc='upper right')
plt.grid(True)
plt.show()
</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">sample_period_to_ref_period = 32
T_rollover = 2**24

EventTimes = np.array(EventTimes)
N_roll_overs = np.array(N_roll_overs)
corrected_lead_t = np.array(corrected_time_l_diff_cut)
corrected_trail_t = np.array(corrected_time_t_diff_cut)

truetime_lead = (EventTimes + N_roll_overs * T_rollover) * sample_period_to_ref_period + corrected_lead_t
truetime_trail = (EventTimes + N_roll_overs * T_rollover) * sample_period_to_ref_period + corrected_trail_t
print(len(truetime_lead))
print(len(truetime_trail))</pre><pre class="hljs"><code>sample_period_to_ref_period = <span class="hljs-number">32</span>
T_rollover = <span class="hljs-number">2</span>**<span class="hljs-number">24</span>

EventTimes = np.<span class="hljs-built_in">array</span>(EventTimes)
N_roll_overs = np.<span class="hljs-built_in">array</span>(N_roll_overs)
corrected_lead_t = np.<span class="hljs-built_in">array</span>(corrected_time_l_diff_cut)
corrected_trail_t = np.<span class="hljs-built_in">array</span>(corrected_time_t_diff_cut)

<span class="hljs-literal">true</span>time_lead = (EventTimes + N_roll_overs * T_rollover) * sample_period_to_ref_period + corrected_lead_t
<span class="hljs-literal">true</span>time_trail = (EventTimes + N_roll_overs * T_rollover) * sample_period_to_ref_period + corrected_trail_t
print(len(<span class="hljs-literal">true</span>time_lead))
print(len(<span class="hljs-literal">true</span>time_trail))</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># --- Cut switches ---
CUT_SEQUENTIAL_ONLY = True

# Convert to np arrays
EventIndices = np.array(EventIndices)
truetime_lead = np.array(truetime_lead)
truetime_trail = np.array(truetime_trail)

# Compute diffs
diff_event_idx = np.diff(EventIndices)
diff_true_lead = np.diff(truetime_lead)
diff_true_trail = np.diff(truetime_trail)

# Initial mask all True
mask = np.ones_like(diff_event_idx, dtype=bool)

# Apply sequential cut only
if CUT_SEQUENTIAL_ONLY:
    mask &amp;= (diff_event_idx == 1)

# Filtered diffs
true_t_lead_diff = diff_true_lead[mask]
true_t_trail_diff = diff_true_trail[mask]

# Report counts
total_lead = len(diff_true_lead)
kept_lead = len(true_t_lead_diff)
cut_lead = total_lead - kept_lead

total_trail = len(diff_true_trail)
kept_trail = len(true_t_trail_diff)
cut_trail = total_trail - kept_trail

print(f&quot;Lead diffs: kept {kept_lead} / total {total_lead} (cut {cut_lead})&quot;)
print(f&quot;Trail diffs: kept {kept_trail} / total {total_trail} (cut {cut_trail})&quot;)</pre><pre class="hljs"><code><span class="hljs-comment"># --- Cut switches ---</span>
CUT_SEQUENTIAL_ONLY = True

<span class="hljs-comment"># Convert to np arrays</span>
EventIndices = np.array(EventIndices)
truetime_lead = np.array(truetime_lead)
truetime_trail = np.array(truetime_trail)

<span class="hljs-comment"># Compute diffs</span>
diff_event_idx = np.diff(EventIndices)
diff_true_lead = np.diff(truetime_lead)
diff_true_trail = np.diff(truetime_trail)

<span class="hljs-comment"># Initial mask all True</span>
mask = np.ones_like(diff_event_idx, dtype=bool)

<span class="hljs-comment"># Apply sequential cut only</span>
if CUT_SEQUENTIAL_ONLY:
    mask &amp;= (diff_event_idx == 1)

<span class="hljs-comment"># Filtered diffs</span>
true_t_lead_diff = diff_true_lead[mask]
true_t_trail_diff = diff_true_trail[mask]

<span class="hljs-comment"># Report counts</span>
total_lead = len(diff_true_lead)
kept_lead = len(true_t_lead_diff)
cut_lead = total_lead - kept_lead

total_trail = len(diff_true_trail)
kept_trail = len(true_t_trail_diff)
cut_trail = total_trail - kept_trail

print(f<span class="hljs-string">&quot;Lead diffs: kept {kept_lead} / total {total_lead} (cut {cut_lead})&quot;</span>)
print(f<span class="hljs-string">&quot;Trail diffs: kept {kept_trail} / total {total_trail} (cut {cut_trail})&quot;</span>)</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

# Compute stats
mu_lead = np.mean(true_t_lead_diff)
sigma_lead = np.std(true_t_lead_diff)

mu_trail = np.mean(true_t_trail_diff)
sigma_trail = np.std(true_t_trail_diff)

# Plot
plt.figure(figsize=(10, 5))
bins = int(np.sqrt(len(true_t_lead_diff)))
plt.hist(true_t_lead_diff, bins=bins, alpha=0.8, label=&quot;Leading Edge&quot;, edgecolor='blue')
plt.hist(true_t_trail_diff, bins=bins, alpha=0.8, label=&quot;Trailing Edge&quot;, edgecolor='orange')
plt.xlabel(&quot;True Time Difference (sequential events only)&quot;)
plt.ylabel(&quot;Count&quot;)
plt.title(&quot;True Time Difference Histogram (Sequential Events, Log Scale)&quot;)
plt.yscale(&quot;log&quot;)
plt.ylim(bottom=0.1)
plt.grid(True)

# Text annotation
text_x = 0.10  # axes fraction
text_y = 0.15  # axes fraction
plt.gca().text(
    text_x, text_y,
    f&quot;Lead μ={mu_lead:.2f}, σ={sigma_lead:.2f}\nTrail μ={mu_trail:.2f}, σ={sigma_trail:.2f}&quot;,
    transform=plt.gca().transAxes,
    fontsize=10,
    verticalalignment='top',
    bbox=dict(facecolor='white', edgecolor='gray', alpha=0.7)
)

plt.legend(loc='upper right')
plt.show()
</pre><pre class="hljs"><code>import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

# Compute stats
mu_lead = np.mean(true_t_lead_diff)
sigma_lead = np.std(true_t_lead_diff)

mu_trail = np.mean(true_t_trail_diff)
sigma_trail = np.std(true_t_trail_diff)

# Plot
plt.figure(figsize=(10, 5))
bins = int(np.sqrt(len(true_t_lead_diff)))
plt.hist(true_t_lead_diff, bins=bins, alpha=0.8, label=&quot;Leading Edge&quot;, edgecolor='blue')
plt.hist(true_t_trail_diff, bins=bins, alpha=0.8, label=&quot;Trailing Edge&quot;, edgecolor='orange')
plt.xlabel(&quot;True Time Difference (sequential events only)&quot;)
plt.ylabel(&quot;Count&quot;)
plt.title(&quot;True Time Difference Histogram (Sequential Events, Log Scale)&quot;)
plt.yscale(&quot;log&quot;)
plt.ylim(bottom=0.1)
plt.grid(True)

# Text annotation
text_x = 0.10  # axes fraction
text_y = 0.15  # axes fraction
plt.gca().text(
    text_x, text_y,
    f&quot;Lead μ={mu_lead:.2f}, σ={sigma_lead:.2f}\nTrail μ={mu_trail:.2f}, σ={sigma_trail:.2f}&quot;,
    transform=plt.gca().transAxes,
    fontsize=10,
    verticalalignment='top',
    bbox=dict(facecolor='white', edgecolor='gray', alpha=0.7)
)

plt.legend(loc='upper right')
plt.show()
</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">from scipy.stats import norm
import numpy as np
import matplotlib.pyplot as plt

# Fit Gaussian to data
mu_lead, sigma_lead = norm.fit(true_t_lead_diff)
mu_trail, sigma_trail = norm.fit(true_t_trail_diff)

# √N binning
num_bins = int(np.sqrt(len(true_t_lead_diff)))

plt.figure(figsize=(10, 5))

# --- Leading Edge Histogram and Fit ---
counts_lead, bin_edges_lead = np.histogram(true_t_lead_diff, bins=num_bins)
bin_centers_lead = 0.5 * (bin_edges_lead[1:] + bin_edges_lead[:-1])
bin_width_lead = bin_edges_lead[1] - bin_edges_lead[0]

# Gaussian PDF scaled to histogram
pdf_lead = norm.pdf(bin_centers_lead, mu_lead, sigma_lead) * np.sum(counts_lead) * bin_width_lead

# Plot histogram with Poisson errors
nonzero_mask_lead = counts_lead &gt; 0
plt.errorbar(
    bin_centers_lead[nonzero_mask_lead],
    counts_lead[nonzero_mask_lead],
    yerr=np.sqrt(counts_lead[nonzero_mask_lead]),
    fmt='o', markersize=3,
    color='blue', markerfacecolor='blue',
    ecolor='black', elinewidth=1, capsize=2, capthick=1,
    label='Leading Edge'
)

plt.plot(bin_centers_lead, pdf_lead, 'b--', label=f&quot;Lead Fit: μ={mu_lead:.2f}, σ={sigma_lead:.2f}&quot;)

# --- Trailing Edge Histogram and Fit ---
counts_trail, bin_edges_trail = np.histogram(true_t_trail_diff, bins=num_bins)
bin_centers_trail = 0.5 * (bin_edges_trail[1:] + bin_edges_trail[:-1])
bin_width_trail = bin_edges_trail[1] - bin_edges_trail[0]

pdf_trail = norm.pdf(bin_centers_trail, mu_trail, sigma_trail) * np.sum(counts_trail) * bin_width_trail

nonzero_mask_trail = counts_trail &gt; 0
plt.errorbar(
    bin_centers_trail[nonzero_mask_trail],
    counts_trail[nonzero_mask_trail],
    yerr=np.sqrt(counts_trail[nonzero_mask_trail]),
    fmt='o', markersize=3,
    color='orange', markerfacecolor='orange',
    ecolor='black', elinewidth=1, capsize=2, capthick=1,
    label='Trailing Edge'
)
plt.plot(bin_centers_trail, pdf_trail, 'orange', linestyle='--', label=f&quot;Trail Fit: μ={mu_trail:.2f}, σ={sigma_trail:.2f}&quot;)

# Labels and formatting
plt.xlabel(&quot;True Time Difference (sequential events only)&quot;)
plt.ylabel(&quot;Count&quot;)
plt.title(&quot;True Time Difference Histogram with Gaussian Fit + Poisson Errors (Log Scale)&quot;)
plt.yscale(&quot;log&quot;)
plt.ylim(bottom=0.1)
plt.grid(True)
plt.legend(loc='upper right')
plt.tight_layout()
plt.show()

# Optional: print stats
print(f&quot;Leading Edge σ: {sigma_lead:.4f}&quot;)
print(f&quot;Trailing Edge σ: {sigma_trail:.4f}&quot;)
</pre><pre class="hljs"><code>from scipy.stats import norm
import numpy as np
import matplotlib.pyplot as plt

# Fit Gaussian to data
mu_lead, sigma_lead = norm.fit(true_t_lead_diff)
mu_trail, sigma_trail = norm.fit(true_t_trail_diff)

# √N binning
num_bins = int(np.sqrt(len(true_t_lead_diff)))

plt.figure(figsize=(10, 5))

# --- Leading Edge Histogram and Fit ---
counts_lead, bin_edges_lead = np.histogram(true_t_lead_diff, bins=num_bins)
bin_centers_lead = 0.5 * (bin_edges_lead[1:] + bin_edges_lead[:-1])
bin_width_lead = bin_edges_lead[1] - bin_edges_lead[0]

# Gaussian PDF scaled to histogram
pdf_lead = norm.pdf(bin_centers_lead, mu_lead, sigma_lead) * np.sum(counts_lead) * bin_width_lead

# Plot histogram with Poisson errors
nonzero_mask_lead = counts_lead &gt; 0
plt.errorbar(
    bin_centers_lead[nonzero_mask_lead],
    counts_lead[nonzero_mask_lead],
    yerr=np.sqrt(counts_lead[nonzero_mask_lead]),
    fmt='o', markersize=3,
    color='blue', markerfacecolor='blue',
    ecolor='black', elinewidth=1, capsize=2, capthick=1,
    label='Leading Edge'
)

plt.plot(bin_centers_lead, pdf_lead, 'b--', label=f&quot;Lead Fit: μ={mu_lead:.2f}, σ={sigma_lead:.2f}&quot;)

# --- Trailing Edge Histogram and Fit ---
counts_trail, bin_edges_trail = np.histogram(true_t_trail_diff, bins=num_bins)
bin_centers_trail = 0.5 * (bin_edges_trail[1:] + bin_edges_trail[:-1])
bin_width_trail = bin_edges_trail[1] - bin_edges_trail[0]

pdf_trail = norm.pdf(bin_centers_trail, mu_trail, sigma_trail) * np.sum(counts_trail) * bin_width_trail

nonzero_mask_trail = counts_trail &gt; 0
plt.errorbar(
    bin_centers_trail[nonzero_mask_trail],
    counts_trail[nonzero_mask_trail],
    yerr=np.sqrt(counts_trail[nonzero_mask_trail]),
    fmt='o', markersize=3,
    color='orange', markerfacecolor='orange',
    ecolor='black', elinewidth=1, capsize=2, capthick=1,
    label='Trailing Edge'
)
plt.plot(bin_centers_trail, pdf_trail, 'orange', linestyle='--', label=f&quot;Trail Fit: μ={mu_trail:.2f}, σ={sigma_trail:.2f}&quot;)

# Labels and formatting
plt.xlabel(&quot;True Time Difference (sequential events only)&quot;)
plt.ylabel(&quot;Count&quot;)
plt.title(&quot;True Time Difference Histogram with Gaussian Fit + Poisson Errors (Log Scale)&quot;)
plt.yscale(&quot;log&quot;)
plt.ylim(bottom=0.1)
plt.grid(True)
plt.legend(loc='upper right')
plt.tight_layout()
plt.show()

# Optional: print stats
print(f&quot;Leading Edge σ: {sigma_lead:.4f}&quot;)
print(f&quot;Trailing Edge σ: {sigma_trail:.4f}&quot;)
</code></pre></div>
<hr>
</div></div>
					</body>
				</html>
			