
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						<link rel="stylesheet" href="pluginAssets/katex/katex.css"><script type="application/javascript" src="pluginAssets/mermaid/mermaid.min.js"></script><script type="application/javascript" src="pluginAssets/mermaid/mermaid_render.js"></script><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>12/05/2024 - 18/05/2024</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">12/05/2024 - 18/05/2024</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}
		::-webkit-scrollbar {
			width: 7px;
			height: 7px;
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(100, 100, 100, 0.3); 
			border-radius: 5px;
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(100, 100, 100, 0.7); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
			font-weight: bold;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to prevent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		.not-loaded-resource img {
			width: 1.15em;
			height: 1.15em;
			background: white;
			padding: 2px !important;
			border-radius: 2px;
			box-shadow: 0 1px 3px #000000aa;
		}

		a.not-loaded-resource img {
			margin-right: .2em;
		}

		a.not-loaded-resource {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 35rem;
			width: 100%;
			max-width: 1000px;
			margin: 0;
			border: 0;
			display: block;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}
.mermaid { width: 640px; }
.mermaid-export-graph {
					opacity: 0;
					height: 0;
					z-index: 1;
					position: relative;
				} 
				.joplin-editable:hover .mermaid-export-graph,
				.joplin-editable .mermaid-export-graph:has(:focus-visible) {
					opacity: 1;
				}
				.mermaid-export-graph > button:hover {
					background-color: #CBDAF1 !important;
				}</style><div id="rendered-md"><h2 id="12052024-2314">12/05/2024 23:14</h2>
<p>To incorporate the ethernet splitter to support the multiple crate system once we set it up, I simply plugged in the 1gbE connection into the ethernet splitter, then ran another wire from the ethernet splitter to the MCH. I was still able to ping the MCH with no edits to the network scripts below:<br>
<strong>/etc/sysconfig/network-script/ifcfg-enp5s0<br>
(1GbE)</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#
# Connect to MCH
#
TYPE=Ethernet
BOOTPROTO=static
IPADDR=192.168.1.1
NETMASK=255.255.255.128
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
NAME=enp5s0
DEVICE=enp5s0
ONBOOT=yes</pre><pre class="hljs"><code><span class="hljs-comment">#</span>
<span class="hljs-comment"># Connect to MCH</span>
<span class="hljs-comment">#</span>
<span class="hljs-attr">TYPE</span>=Ethernet
<span class="hljs-attr">BOOTPROTO</span>=static
<span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>
<span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.128</span>
<span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERDNS</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERROUTES</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">NAME</span>=enp5s0
<span class="hljs-attr">DEVICE</span>=enp5s0
<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span></code></pre></div>
<p>However, we need to support a second crate that will be on the 192.186.{crate #}.xxx network, so I changed the netmask to accept any value from the 3rd octet of the IP address:</p>
<p><strong>/etc/sysconfig/network-script/ifcfg-enp5s0<br>
(1GbE)</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#
# Connect to MCH
#
TYPE=Ethernet
BOOTPROTO=static
IPADDR=192.168.1.1
NETMASK=255.255.255.128
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
NAME=enp5s0
DEVICE=enp5s0
ONBOOT=yes</pre><pre class="hljs"><code><span class="hljs-comment">#</span>
<span class="hljs-comment"># Connect to MCH</span>
<span class="hljs-comment">#</span>
<span class="hljs-attr">TYPE</span>=Ethernet
<span class="hljs-attr">BOOTPROTO</span>=static
<span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>
<span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.128</span>
<span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERDNS</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERROUTES</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">NAME</span>=enp5s0
<span class="hljs-attr">DEVICE</span>=enp5s0
<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span></code></pre></div>
<hr>
<h2 id="13052024-0026">13/05/2024 00:26</h2>
<p>Poll event seems to lock the gpu thread to poll if data is available.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">INT poll_event(INT source __attribute__((unused)), INT count, BOOL test)
{
  // fake calibration
  if (test) {
    for (int i = 0; i &lt; count; i++) {
      usleep(1);
    }
    return 0;
  }

  INT retval = 0; 
  BOOL data_avail = FALSE;          // true if data is available for readout

  // Check GPU buffer
  pthread_mutex_lock( &amp;mutex_GPU_general );
  if (GPUfillnumber &gt; Midasfillnumber)
  {
    data_avail = TRUE;
  }
  if (GPUfillnumber &lt; Midasfillnumber &amp;&amp; GPUfillnumber!=0) // this is for wrapping over the largest unsigned long, which is not very probable if the run is short
  {
    unsigned long buffer_filled = 0xffffffffffffffff - (Midasfillnumber - GPUfillnumber) +1 ;
    if (buffer_filled &lt; 0xffffffffffffffff / 2)
    {
      data_avail = TRUE;
    }
  }
  pthread_mutex_unlock( &amp;mutex_GPU_general );

//  if (run_state == STATE_RUNNING) {
    if (data_avail) {
      retval = 1;
    }
//  }
  return retval; 
} // poll_event</pre><pre class="hljs"><code><span class="hljs-keyword">INT</span> poll_event(<span class="hljs-keyword">INT</span> <span class="hljs-keyword">source</span> __attribute__((unused)), <span class="hljs-keyword">INT</span> <span class="hljs-keyword">count</span>, BOOL test)
{
  <span class="hljs-comment">// fake calibration</span>
  <span class="hljs-keyword">if</span> (test) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">count</span>; i++) {
      usleep(<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-keyword">INT</span> retval = <span class="hljs-number">0</span>; 
  BOOL data_avail = <span class="hljs-keyword">FALSE</span>;          <span class="hljs-comment">// true if data is available for readout</span>

  <span class="hljs-comment">// Check GPU buffer</span>
  pthread_mutex_lock( &amp;mutex_GPU_general );
  <span class="hljs-keyword">if</span> (GPUfillnumber &gt; Midasfillnumber)
  {
    data_avail = <span class="hljs-keyword">TRUE</span>;
  }
  <span class="hljs-keyword">if</span> (GPUfillnumber &lt; Midasfillnumber &amp;&amp; GPUfillnumber!=<span class="hljs-number">0</span>) <span class="hljs-comment">// this is for wrapping over the largest unsigned long, which is not very probable if the run is short</span>
  {
    unsigned <span class="hljs-keyword">long</span> buffer_filled = <span class="hljs-number">0</span>xffffffffffffffff - (Midasfillnumber - GPUfillnumber) +<span class="hljs-number">1</span> ;
    <span class="hljs-keyword">if</span> (buffer_filled &lt; <span class="hljs-number">0</span>xffffffffffffffff / <span class="hljs-number">2</span>)
    {
      data_avail = <span class="hljs-keyword">TRUE</span>;
    }
  }
  pthread_mutex_unlock( &amp;mutex_GPU_general );

<span class="hljs-comment">//  if (run_state == STATE_RUNNING) {</span>
    <span class="hljs-keyword">if</span> (data_avail) {
      retval = <span class="hljs-number">1</span>;
    }
<span class="hljs-comment">//  }</span>
  <span class="hljs-keyword">return</span> retval; 
} <span class="hljs-comment">// poll_event</span></code></pre></div>
<p>Though, this shouldn't be problematic because this check is short and isn't done until it can obtain the lock anyways.</p>
<hr>
<h2 id="13052024-0059">13/05/2024 00:59</h2>
<p>I've tracked down where all the timestamps are made:</p>
<ol>
<li>TCP proc unlocked, tcp_thread.cxx:624<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// get time of start of read / unpack AMC13 event
status = gettimeofday( &amp;tstart, NULL);
header[1] = tstart.tv_sec;  // fill header time info in header
header[2] = tstart.tv_usec; // fill header time info in header</pre><pre class="hljs"><code>// get time of start of read / unpack AMC13 event
status = gettimeofday( &amp;tstart, NU<span class="hljs-class">LL);</span>
header[1] = tstart.tv_sec;  //<span class="hljs-built_in"> fill </span>header time info in header
header[2] = tstart.tv_usec; //<span class="hljs-built_in"> fill </span>header time info in header</code></pre></div>
</li>
<li>got TCP header word, tcp_thread.cxx:1041<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// record time got header word
gettimeofday( &amp;theader, NULL);
header[3] = theader.tv_sec; // fill header time info in header
header[4] = theader.tv_usec; // fill header time info in header</pre><pre class="hljs"><code>// record time got header word
gettimeofday( &amp;theader, NU<span class="hljs-class">LL);</span>
header[3] = theader.tv_sec; //<span class="hljs-built_in"> fill </span>header time info in header
header[4] = theader.tv_usec; //<span class="hljs-built_in"> fill </span>header time info in header</code></pre></div>
</li>
<li>got TCP header word 2, tcp_thread.cxx:670<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// get time done read / unpack of AMC13 event 
status = gettimeofday( &amp;tdata, NULL);
header[5] = tdata.tv_sec; // fill data time info in header
header[6] = tdata.tv_usec; // fill data time info in header</pre><pre class="hljs"><code>// get time done read / unpack of AMC13 event 
status = gettimeofday( &amp;tdata, NU<span class="hljs-class">LL);</span>
header[5] = tdata.tv_sec; //<span class="hljs-built_in"> fill </span>data time info in header
header[6] = tdata.tv_usec; //<span class="hljs-built_in"> fill </span>data time info in header</code></pre></div>
</li>
<li>GPU proc unlocked, gpu_thread.cpp:557<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">gettimeofday( &amp;tstart, NULL);</pre><pre class="hljs"><code>gettimeof<span class="hljs-meta">day</span>( <span class="hljs-variable">&amp;tstart</span>, <span class="hljs-keyword">NULL</span>);</code></pre></div>
about 40 lines later...<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">//Add the GPU processing start time stamp
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[7] = tstart.tv_sec; 
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[8] = tstart.tv_usec; </pre><pre class="hljs"><code>//Add the GPU processing start time stamp
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[<span class="hljs-number">7</span>] <span class="hljs-operator">=</span> tstart.tv_sec<span class="hljs-comment">; </span>
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[<span class="hljs-number">8</span>] <span class="hljs-operator">=</span> tstart.tv_usec<span class="hljs-comment">; </span></code></pre></div>
</li>
<li>GPU copy done, gpu_thread.cpp:701<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// get GPU copy time for GPU thread
gettimeofday( &amp;tcopy, NULL);
dbprintf(&quot;%s(%d): duration of start to copy, fdt = %e us \n&quot;, __func__, __LINE__, toddiff( &amp;tstart, &amp;tcopy) );
trigger_info.time_gputhread_copytogpu_done_s = tcopy.tv_sec;
trigger_info.time_gputhread_copytogpu_done_us = tcopy.tv_usec;     
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[9] = tcopy.tv_sec; // fill copy to GPU time info in header
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[10] = tcopy.tv_usec; // fill copy to GPU time info in header</pre><pre class="hljs"><code>// get GPU copy time for GPU thread
gettimeofday( &amp;tcopy, NU<span class="hljs-class">LL);</span>
dbprintf(<span class="hljs-string">&quot;%s(%d): duration of start to copy, fdt = %e us \n&quot;</span>, __func__, __LINE__, toddiff( &amp;tstart, &amp;tcopy) );
trigger_info.time_gputhread_copytogpu_done_s = tcopy.tv_sec;
trigger_info.time_gputhread_copytogpu_done_us = tcopy.tv_usec;     
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[9] = tcopy.tv_sec; //<span class="hljs-built_in"> fill </span>copy to GPU time info in header
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[10] = tcopy.tv_usec; //<span class="hljs-built_in"> fill </span>copy to GPU time info in header</code></pre></div>
</li>
<li>GPU proc done, gpu_thread.cpp:765<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// get GPU run time for GPU thread
gettimeofday( &amp;tprocess, NULL);
dbprintf(&quot;%s(%d): duration of copy to process, fdt = %e us \n&quot;, __func__, __LINE__, toddiff( &amp;tprocess, &amp;tcopy) );
trigger_info.time_gputhread_finished_s = tprocess.tv_sec;
trigger_info.time_gputhread_finished_us = tprocess.tv_usec;     
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[11] = tprocess.tv_sec;
GPU_Data_Buffer[GPUbufferindex].gpu_data_header[12] = tprocess.tv_usec;</pre><pre class="hljs"><code>// get GPU run time for GPU <span class="hljs-keyword">thread</span>
gettimeofday( &amp;tprocess, NULL)<span class="hljs-comment">;</span>
dbprintf(<span class="hljs-string">&quot;%s(%d): duration of copy to process, fdt = %e us \n&quot;</span>, __func__, __LINE__, toddiff( &amp;tprocess, &amp;tcopy) )<span class="hljs-comment">;</span>
trigger_info.time_gputhread_finished_s = tprocess.tv_sec<span class="hljs-comment">;</span>
trigger_info.time_gputhread_finished_us = tprocess.tv_usec<span class="hljs-comment">;     </span>
GPU_Dat<span class="hljs-built_in">a_Buffer</span>[GPUbufferindex].gpu_dat<span class="hljs-built_in">a_header</span>[<span class="hljs-number">11</span>] = tprocess.tv_sec<span class="hljs-comment">;</span>
GPU_Dat<span class="hljs-built_in">a_Buffer</span>[GPUbufferindex].gpu_dat<span class="hljs-built_in">a_header</span>[<span class="hljs-number">12</span>] = tprocess.tv_usec<span class="hljs-comment">;</span></code></pre></div>
</li>
<li>MFE proc unlocked, frontend.cpp:2714<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">  status = gettimeofday( &amp;t_lock_data, NULL);
  trigger_info.time_slave_lock_dataready_s  = t_lock_data.tv_sec;
  trigger_info.time_slave_lock_dataready_us = t_lock_data.tv_usec;

  // store timing information and current TCPfillnumber, GPUfillnumber in header databank
  GPUDATA-&gt;gpu_data_header[13] = t_lock_data.tv_sec;
  GPUDATA-&gt;gpu_data_header[14] = t_lock_data.tv_usec;</pre><pre class="hljs"><code>  status = gettimeofday( &amp;t_lock_data, <span class="hljs-literal">NULL</span>);
  trigger_info.time_slave_lock_dataready_s  = t_lock_data.tv_sec;
  trigger_info.time_slave_lock_dataready_us = t_lock_data.tv_usec;

  <span class="hljs-comment">// store timing information and current TCPfillnumber, GPUfillnumber in header databank</span>
  GPUDATA-&gt;gpu_data_header[<span class="hljs-number">13</span>] = t_lock_data.tv_sec;
  GPUDATA-&gt;gpu_data_header[<span class="hljs-number">14</span>] = t_lock_data.tv_usec;</code></pre></div>
</li>
<li>MFE banks made, frontend.cpp:3288<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">  status = gettimeofday( &amp;t_got_data, NULL);
  trigger_info.time_slave_got_data_s  = t_got_data.tv_sec;
  trigger_info.time_slave_got_data_us = t_got_data.tv_usec;

  // make more header / timing data
  // array elements 17, 18 reserced for compression timing data
  GPUDATA-&gt;gpu_data_header[15] = t_got_data.tv_sec;
  GPUDATA-&gt;gpu_data_header[16] = t_got_data.tv_usec;</pre><pre class="hljs"><code>  status = gettimeofday( &amp;t_got_data, NU<span class="hljs-class">LL);</span>
  trigger_info.time_slave_got_data_s  = t_got_data.tv_sec;
  trigger_info.time_slave_got_data_us = t_got_data.tv_usec;

  // make more header / timing data
  //<span class="hljs-built_in"> array </span>elements 17, 18 reserced for compression timing data
  GPUDATA-&gt;gpu_data_header[15] = t_got_data.tv_sec;
  GPUDATA-&gt;gpu_data_header[16] = t_got_data.tv_usec;</code></pre></div>
</li>
<li>lossless compression, frontend.cpp:3463<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">  status = gettimeofday( &amp;t_done_compression, NULL);
  perf_data[17] = t_done_compression.tv_sec;
  perf_data[18] = t_done_compression.tv_usec;</pre><pre class="hljs"><code>  status = gettimeof<span class="hljs-meta">day</span>( <span class="hljs-variable">&amp;t_done_compression</span>, <span class="hljs-keyword">NULL</span>);
  perf_data[17] = t_done_compression.tv_sec;
  perf_data[18] = t_done_compression.tv_usec;</code></pre></div>
</li>
</ol>
<h2 id="13052024-0103">13/05/2024 01:03</h2>
<p>What happens in between each time step?</p>
<ol>
<li><strong>got TCP header word - TCP proc unlocked</strong>
<ol>
<li>Lock TCP thread, call part of read and unpack<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    pthread_mutex_lock( &amp;mutex_TCP_buf[bufIndex] );  

    // function reads / unpacks the AMC13 block structure
    gettimeofday( &amp;tbeginread, NULL);
    databytes = readAndUnpack( bufIndex );</pre><pre class="hljs"><code>    pthread_mutex_lock( <span class="hljs-variable">&amp;mutex_TCP_buf</span>[bufIndex] );  

    // function reads / unpacks the AMC13 block structure
    gettimeof<span class="hljs-meta">day</span>( <span class="hljs-variable">&amp;tbeginread</span>, <span class="hljs-keyword">NULL</span>);
    databytes = readAndUnpack( bufIndex );</code></pre></div>
</li>
<li>Declare local read and unpack variables, read first word:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">int readAndUnpack(int bufIndex){

//#ifdef DEBUG
  unsigned int EventIndex;  // AMC13 reported event number
  unsigned int OverallSize; // event size in AMC13 header
//#endif
  int iAMC, nAMC;  // AMC13 reported number of AMC modules 

//#ifdef DEBUG
  int local_headerbytes = TCPheadersize;
//#endif

  int block_status = 0;

  int retval = ReadXBytes( clientsockfd,  sizeof(uint64_t), (void*)( header ),block_status );
//  printf(&quot;Read Header: %d vs %d&quot;,retval, sizeof(uint64_t));

  // get overall CDF header word
  if (retval &lt; int(sizeof(uint64_t)))
  {
    if ( retval &lt; 0 ) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Cannot read header from socket&quot;);                                 
      return -1;                                                                  
    }else if (retval == 0)
    {
      if (block_status == 1 )
      {
    return 0;
      }else{
    cm_msg(MERROR, __FILE__, &quot;Cannot read header from socket&quot;);                                 
    return -1;                                                                  
      }
    }else{
    cm_msg(MERROR, __FILE__, &quot;Cannot read header from socket&quot;);                                 
      return -1;
    }
  }

  // get event number from header bank
//#ifdef DEBUG
  EventIndex = getEventIndex( be64toh( *header ) );
//#endif

  // pointer location to AMC13 unpacking info in amc13info data array
  offsetamc13info = amc13info;
  // write CDF header word in the amc13info array
  *offsetamc13info = *header;
  dbprintf(&quot;%s(%d): read header, header size [bytes] %d, header[0] 0x%016lX, BODdelimiter 0x%016lX, BODmask 0x%016lx Event number %i\n&quot;, 
         __func__, __LINE__, local_headerbytes, *offsetamc13info, BODdelimiter, BODmask, EventIndex );
  offsetamc13info++;

  // record time got header word
  gettimeofday( &amp;theader, NULL);
  header[3] = theader.tv_sec; // fill header time info in header
  header[4] = theader.tv_usec; // fill header time info in header</pre><pre class="hljs"><code>int readAndUnpack(int bufIndex){

//#ifdef DEBUG
  unsigned int EventIndex;  // AMC13 reported event number
  unsigned int OverallSize; // event size in AMC13 header
//#endif
  int iAMC, nAMC;  // AMC13 reported number of AMC modules 

//#ifdef DEBUG
  int local_headerbytes = TCPheadersize;
//#endif

  int block_status = 0;

  int retval = ReadXBytes( clientsockfd,  sizeof(uint64_t), (void*)( header ),block_status );
//  printf(&quot;Read Header: %d vs %d&quot;,retval, sizeof(uint64_t));

  // get overall CDF header word
  if (retval &lt; int(sizeof(uint64_t)))
  {
    if ( retval &lt; 0 ) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Cannot read header from socket&quot;);                                 
      return -1;                                                                  
    }else if (retval == 0)
    {
      if (block_status == 1 )
      {
    return 0;
      }else{
    cm_msg(MERROR, __FILE__, &quot;Cannot read header from socket&quot;);                                 
    return -1;                                                                  
      }
    }else{
    cm_msg(MERROR, __FILE__, &quot;Cannot read header from socket&quot;);                                 
      return -1;
    }
  }

  // get event number from header bank
//#ifdef DEBUG
  EventIndex = getEventIndex( be64toh( *header ) );
//#endif

  // pointer location to AMC13 unpacking info in amc13info data array
  offsetamc13info = amc13info;
  // write CDF header word in the amc13info array
  *offsetamc13info = *header;
  dbprintf(&quot;%s(%d): read header, header size [bytes] %d, header[0] 0x%016lX, BODdelimiter 0x%016lX, BODmask 0x%016lx Event number %i\n&quot;, 
         __func__, __LINE__, local_headerbytes, *offsetamc13info, BODdelimiter, BODmask, EventIndex );
  offsetamc13info++;

  // record time got header word
  gettimeofday( &amp;theader, NULL);
  header[3] = theader.tv_sec; // fill header time info in header
  header[4] = theader.tv_usec; // fill header time info in header</code></pre></div>
</li>
</ol>
</li>
<li><strong>got TCP header word 2 - got TCP header word</strong>
<ol>
<li>The rest of read and unpack happens:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">dbprintf(&quot;%s(%d): duration from AVAIL lock to fill header bank, buffer[%d], fill %d, duration %e us \n&quot;, 
         __func__, __LINE__, bufIndex, TCPfillnumber, toddiff( &amp;theader, &amp;tstart) );

  // byte / block counters for AMC modules x AMC blocks readoout structure
  int blockdatabytes = 0; // individual AMC module bytes per AMC13 block
  int totaldatabytes = 0; // running total of all AMC modules data bytes 
  int blockcount = 0;     // AMC13  block counters

  // data offsets for unpacking data buffer structure of AMCs x blocks
  unsigned int dataoffset = 0, datablockoffset[12], dataAMCoffset[12];
  memset( datablockoffset, 0, sizeof(datablockoffset) ); // block offset of particular AMC modules data
  memset( dataAMCoffset, 0, sizeof(dataAMCoffset) ); // overall offset of particular AMC modules data

  bool moredata = 1; // more data is true of more blocks are available
  while ( moredata ){  // loops over AMC data blocks 

    // read single 64-bit AMC13 block header word
    //Try reading 1 times before giving up
    int read_fail = 0;
    while (read_fail&lt;1)
    {
      retval  = ReadXBytes( clientsockfd, sizeof(uint64_t), (void*)( offsetamc13info ) ,block_status);
      if (retval&gt;0)
      {
    break;
      }
      usleep(100000);
      read_fail++;
    }
    if (read_fail&gt;=1)
    {
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d, for %d times&quot;, clientsockfd,retval,sizeof(uint64_t),read_fail);  
      cm_msg(MERROR,__FILE__, &quot;read header, header size [bytes] %d, header[0] 0x%016lX, BODdelimiter 0x%016lX, BODmask 0x%016lx Event number %i&quot;,local_headerbytes, *offsetamc13info, BODdelimiter, BODmask, EventIndex);
    }
    if ( retval &lt; int(sizeof(uint64_t)) ) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,sizeof(uint64_t));  
      cm_msg(MERROR,__FILE__, &quot;read header, header size [bytes] %d, header[0] 0x%016lX, BODdelimiter 0x%016lX, BODmask 0x%016lx Event number %i&quot;,local_headerbytes, *offsetamc13info, BODdelimiter, BODmask, EventIndex);
      return -1;                                                                  
    }

    // get the number of enabled AMCs
    nAMC = getAMCNum( be64toh( *offsetamc13info ) );
    offsetamc13info++;
    dbprintf(&quot;%s(%d): reading AMC general header word 0x%016lX, nAMC decoded %i\n&quot;, 
         __func__, __LINE__, *offsetamc13info, getAMCNum( be64toh( *offsetamc13info ) ) );

    // WARN if mismatch between ODB and AMC13 headers / trailers for number of active modules for first block
    if ( ( blockcount == 0 ) &amp;&amp; ( nAMC != NRiderModuleEnabled ) ) {
      cm_msg(MERROR, __FILE__, &quot;WARNING! mismatch between ODB (%i) and AMC13 headers (%i) for number of AMC modules&quot;, NRiderModuleEnabled, nAMC);
      dbprintf(&quot;%s(%d): WARNING! mis-match between ODB (%i) and AMC13 headers (%i) for number of AMC modules\n&quot;, __func__, __LINE__,  NRiderModuleEnabled, nAMC);
    }

    // read 64-bit AMC module header words - one per AMC
    retval  = ReadXBytes( clientsockfd, nAMC*sizeof(uint64_t), (void*)( offsetamc13info) ,block_status);
    if ( retval &lt; int(nAMC*sizeof(uint64_t)) ) 
      {                                                                                    
    cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,nAMC*sizeof(uint64_t));  
    return -1;                                                                  
      }

    // WARN if mismatch between ODB and AMC13 headers / trailers for AMC slot number
    for (iAMC = 0; iAMC &lt; nAMC; iAMC++){
      if ( !amc13_rider_odb[amc_header_info[iAMC].AMCSlotNum-1].board.rider_enabled ) {
    //cm_msg(MERROR, __FILE__, &quot;WARNING! AMC slot %i not enabled in ODB&quot;, amc_header_info[iAMC].AMCSlotNum);
    dbprintf(&quot;%s(%d): WARNING! amc_header_info[iAMC].AMCSlot %i\n&quot;, __func__, __LINE__, amc_header_info[iAMC].AMCSlotNum);
      }
    }

    // decode AMC header words - get continuation bits, event / block size, AMC slot number
    // set moredata = 1 if more blocks are following this block
    moredata = 0;
    for (iAMC = 0; iAMC &lt; nAMC; iAMC++){
      if ( decodeAMCHeader( iAMC, be64toh( *( offsetamc13info ) ) ) != 0 )
    {
      printf(&quot;decodeAMCHeader() failed!&quot;);
    }
      offsetamc13info++;
      if (amc_header_info[iAMC].AMCMoreBit) moredata = 1;

     dbprintf(&quot;%s(%d): AMC index %d, AMC Slot number %d, AMCMoreBit %d, more data %d, AMCEventSize 0x%08x\n&quot;, 
          __func__, __LINE__, iAMC, amc_header_info[iAMC].AMCSlotNum, amc_header_info[iAMC].AMCMoreBit,  moredata, amc_header_info[iAMC].AMCEventSize );
    }

    // calculate AMC data offsets dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1] from total event sizes in S=0 word AMC header word  
    // (i.e. for either M=1,S=0 with continuation blocks or M=0,S=0 with only one block)
    // This calculation is performed once per fill / event and hanfles different total data sizes, 
    // i.e. amc_header_info[iAMC].AMCEventSize, from different amcmodules
    if ( !amc_header_info[0].AMCSegBit ) {
      int AMCoffsetbytes = 0;      
      for (iAMC = 0; iAMC &lt; nAMC; iAMC++){
    dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1] = AMCoffsetbytes / sizeof(uint64_t);
    dbprintf(&quot;%s(%d): blockcount %d, AMC index %d, calculated AMC total data offset 0x%08x\n&quot;, 
         __func__, __LINE__, blockcount, iAMC, dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1]); 
    AMCoffsetbytes += sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;
      }
    }

    // read AMC data block
    for (iAMC = 0; iAMC &lt; nAMC; iAMC++){

      // calculate the data bytes - blockdatabytes - to read for each AMC module with index iAMC 
      // bits determine if first block, intermediate block, last block or single block
      if ( amc_header_info[iAMC].AMCMoreBit &amp;&amp; (!amc_header_info[iAMC].AMCSegBit) )
    {
      blockdatabytes = 32768;
      dbprintf(&quot;M=1,S=0 first block in segment, set size to 0x%08x bytes (odb 0x%08x)\n&quot;, 
           blockdatabytes, amc13_amc13_odb.amc_block_size);
    }
      if ( amc_header_info[iAMC].AMCMoreBit &amp;&amp; amc_header_info[iAMC].AMCSegBit )
    {
      dbprintf(&quot;M=1,S=1 intermediate block in segment, set size from amc header word\n&quot;);
      blockdatabytes = sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;
    }
      if ( (!amc_header_info[iAMC].AMCMoreBit) &amp;&amp; amc_header_info[iAMC].AMCSegBit )
    {
      dbprintf(&quot;M=0,S=1 last block in segment, set size from amc header word\n&quot;);
      blockdatabytes = sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;	  
    }
      if ( (!amc_header_info[iAMC].AMCMoreBit) &amp;&amp; (!amc_header_info[iAMC].AMCSegBit) )
    {
      dbprintf(&quot;M=0,S=0 only block in segment, set size from amc header word\n&quot;);
      blockdatabytes = sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;
    }

      // calculated the location to put the data from block structure in AMC13 event
      dataoffset = dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1] + datablockoffset[amc_header_info[iAMC].AMCSlotNum-1];
      dbprintf(&quot;%s(%d): blockcount %d, iAMC %d, calculated AMC+Block data offset 0x%08x block data bytes 0x%08x data bytes total 0x%08x\n&quot;, 
           __func__, __LINE__, blockcount, iAMC, dataoffset, blockdatabytes, totaldatabytes); 

      // read the data block for each AMC module in array tcp_buf_gl[bufIndex]
      retval  = ReadXBytes( clientsockfd, blockdatabytes, (void*)( tcp_buf_gl[bufIndex] + dataoffset ) ,block_status);
    if ( retval &lt; blockdatabytes) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,blockdatabytes);  
      return -1;                                                                  
    }
      dbprintf(&quot;%s(%d): done reading AMC block %i bytes %i, dataoffset %d, (tcp_buf_gl[bufIndex] + dataoffset ) %p, data[0] 0x%16lx data[1] 0x%16lx\n&quot;, 
           __func__, __LINE__, blockcount, blockdatabytes, dataoffset, ( tcp_buf_gl[bufIndex] + dataoffset ), 
           *( tcp_buf_gl[bufIndex] + dataoffset ), *( tcp_buf_gl[bufIndex] + dataoffset + 1 ) ); 

      //dataoffset += blockdatabytes/sizeof(uint64_t); // redundant so removed?
      datablockoffset[amc_header_info[iAMC].AMCSlotNum-1] += blockdatabytes/sizeof(uint64_t); // datablockoffset[i] is individual payload readout from ith AMC module
      totaldatabytes += blockdatabytes; // totaldatabytes is total payload readout from all AMC modules
      dbprintf(&quot;%s(%d): end of read loop for amc %i\n&quot;,__func__, __LINE__,iAMC);
    }

    // read single 64-bit AMC13 block trailer word
    retval = ReadXBytes( clientsockfd, sizeof(uint64_t), (void*)( offsetamc13info ) ,block_status);
    if ( retval &lt; int(sizeof(uint64_t))) 
      {                                                                                    
    cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,sizeof(uint64_t));  
    return -1;                                                                  
      }
    dbprintf(&quot;%s(%d): done reading AMC block %i, trailer word *tmp 0x%08lx\n&quot;, 
         __func__, __LINE__, blockcount, *offsetamc13info); 

    offsetamc13info++;
    blockcount++;
  }
  dbprintf(&quot;%s(%d): finished data read / unpack, databytes total 0x%08x block count %i\n&quot;, 
       __func__, __LINE__, totaldatabytes, blockcount); 

  // get CDF trailer word
  retval = ReadXBytes( clientsockfd, tailbytes, (void*)(tail) ,block_status);
  if ( retval &lt; int(tailbytes)) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,tailbytes);  
      return -1;                                                                  
    }

#ifdef DEBUG
  OverallSize = getOverallSize( be64toh(tail[0]) );
#endif

  dbprintf(&quot;%s(%d): read trailer, trailer size [bytes] %d, tail[0] 0x%016lX, EODdelimiter 0x%016lX, EODmask 0x%016lX, Overall Size %i\n&quot;, 
       __func__, __LINE__, tailbytes, be64toh(tail[0]), EODdelimiter, EODmask, OverallSize);

#if 0 // turn on/off CPU-based byte-reordering in 8-byte AMC13 words 

  // re-order data from network / big-endian to little-endian
  struct timeval tbeforeReorderBytes, tafterReorderBytes;
  gettimeofday( &amp;tbeforeReorderBytes, NULL);

  int iReorderBytes, nReorderBytes = totaldatabytes / sizeof(uint64_t);
  for (iReorderBytes = 0; iReorderBytes &lt; nReorderBytes; iReorderBytes++){
    tcp_buf_gl[bufIndex][iReorderBytes] = be64toh( tcp_buf_gl[bufIndex][iReorderBytes] );
  }

  gettimeofday( &amp;tafterReorderBytes, NULL);
  dbprintf(&quot;%s(%d): duration of byte re-ordering, buffer[%d], fill %d, duration %e us \n&quot;, 
     __func__, __LINE__, bufIndex, TCPfillnumber, toddiff( &amp;tafterReorderBytes, &amp;tbeforeReorderBytes) );
#endif 

  return totaldatabytes;
}</pre><pre class="hljs"><code>dbprintf(&quot;%s(%d): duration from AVAIL lock to fill header bank, buffer[%d], fill %d, duration %e us \n&quot;, 
         __func__, __LINE__, bufIndex, TCPfillnumber, toddiff( &amp;theader, &amp;tstart) );

  // byte / block counters for AMC modules x AMC blocks readoout structure
  int blockdatabytes = 0; // individual AMC module bytes per AMC13 block
  int totaldatabytes = 0; // running total of all AMC modules data bytes 
  int blockcount = 0;     // AMC13  block counters

  // data offsets for unpacking data buffer structure of AMCs x blocks
  unsigned int dataoffset = 0, datablockoffset[12], dataAMCoffset[12];
  memset( datablockoffset, 0, sizeof(datablockoffset) ); // block offset of particular AMC modules data
  memset( dataAMCoffset, 0, sizeof(dataAMCoffset) ); // overall offset of particular AMC modules data

  bool moredata = 1; // more data is true of more blocks are available
  while ( moredata ){  // loops over AMC data blocks 

    // read single 64-bit AMC13 block header word
    //Try reading 1 times before giving up
    int read_fail = 0;
    while (read_fail&lt;1)
    {
      retval  = ReadXBytes( clientsockfd, sizeof(uint64_t), (void*)( offsetamc13info ) ,block_status);
      if (retval&gt;0)
      {
    break;
      }
      usleep(100000);
      read_fail++;
    }
    if (read_fail&gt;=1)
    {
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d, for %d times&quot;, clientsockfd,retval,sizeof(uint64_t),read_fail);  
      cm_msg(MERROR,__FILE__, &quot;read header, header size [bytes] %d, header[0] 0x%016lX, BODdelimiter 0x%016lX, BODmask 0x%016lx Event number %i&quot;,local_headerbytes, *offsetamc13info, BODdelimiter, BODmask, EventIndex);
    }
    if ( retval &lt; int(sizeof(uint64_t)) ) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,sizeof(uint64_t));  
      cm_msg(MERROR,__FILE__, &quot;read header, header size [bytes] %d, header[0] 0x%016lX, BODdelimiter 0x%016lX, BODmask 0x%016lx Event number %i&quot;,local_headerbytes, *offsetamc13info, BODdelimiter, BODmask, EventIndex);
      return -1;                                                                  
    }

    // get the number of enabled AMCs
    nAMC = getAMCNum( be64toh( *offsetamc13info ) );
    offsetamc13info++;
    dbprintf(&quot;%s(%d): reading AMC general header word 0x%016lX, nAMC decoded %i\n&quot;, 
         __func__, __LINE__, *offsetamc13info, getAMCNum( be64toh( *offsetamc13info ) ) );

    // WARN if mismatch between ODB and AMC13 headers / trailers for number of active modules for first block
    if ( ( blockcount == 0 ) &amp;&amp; ( nAMC != NRiderModuleEnabled ) ) {
      cm_msg(MERROR, __FILE__, &quot;WARNING! mismatch between ODB (%i) and AMC13 headers (%i) for number of AMC modules&quot;, NRiderModuleEnabled, nAMC);
      dbprintf(&quot;%s(%d): WARNING! mis-match between ODB (%i) and AMC13 headers (%i) for number of AMC modules\n&quot;, __func__, __LINE__,  NRiderModuleEnabled, nAMC);
    }

    // read 64-bit AMC module header words - one per AMC
    retval  = ReadXBytes( clientsockfd, nAMC*sizeof(uint64_t), (void*)( offsetamc13info) ,block_status);
    if ( retval &lt; int(nAMC*sizeof(uint64_t)) ) 
      {                                                                                    
    cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,nAMC*sizeof(uint64_t));  
    return -1;                                                                  
      }

    // WARN if mismatch between ODB and AMC13 headers / trailers for AMC slot number
    for (iAMC = 0; iAMC &lt; nAMC; iAMC++){
      if ( !amc13_rider_odb[amc_header_info[iAMC].AMCSlotNum-1].board.rider_enabled ) {
    //cm_msg(MERROR, __FILE__, &quot;WARNING! AMC slot %i not enabled in ODB&quot;, amc_header_info[iAMC].AMCSlotNum);
    dbprintf(&quot;%s(%d): WARNING! amc_header_info[iAMC].AMCSlot %i\n&quot;, __func__, __LINE__, amc_header_info[iAMC].AMCSlotNum);
      }
    }

    // decode AMC header words - get continuation bits, event / block size, AMC slot number
    // set moredata = 1 if more blocks are following this block
    moredata = 0;
    for (iAMC = 0; iAMC &lt; nAMC; iAMC++){
      if ( decodeAMCHeader( iAMC, be64toh( *( offsetamc13info ) ) ) != 0 )
    {
      printf(&quot;decodeAMCHeader() failed!&quot;);
    }
      offsetamc13info++;
      if (amc_header_info[iAMC].AMCMoreBit) moredata = 1;

     dbprintf(&quot;%s(%d): AMC index %d, AMC Slot number %d, AMCMoreBit %d, more data %d, AMCEventSize 0x%08x\n&quot;, 
          __func__, __LINE__, iAMC, amc_header_info[iAMC].AMCSlotNum, amc_header_info[iAMC].AMCMoreBit,  moredata, amc_header_info[iAMC].AMCEventSize );
    }

    // calculate AMC data offsets dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1] from total event sizes in S=0 word AMC header word  
    // (i.e. for either M=1,S=0 with continuation blocks or M=0,S=0 with only one block)
    // This calculation is performed once per fill / event and hanfles different total data sizes, 
    // i.e. amc_header_info[iAMC].AMCEventSize, from different amcmodules
    if ( !amc_header_info[0].AMCSegBit ) {
      int AMCoffsetbytes = 0;      
      for (iAMC = 0; iAMC &lt; nAMC; iAMC++){
    dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1] = AMCoffsetbytes / sizeof(uint64_t);
    dbprintf(&quot;%s(%d): blockcount %d, AMC index %d, calculated AMC total data offset 0x%08x\n&quot;, 
         __func__, __LINE__, blockcount, iAMC, dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1]); 
    AMCoffsetbytes += sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;
      }
    }

    // read AMC data block
    for (iAMC = 0; iAMC &lt; nAMC; iAMC++){

      // calculate the data bytes - blockdatabytes - to read for each AMC module with index iAMC 
      // bits determine if first block, intermediate block, last block or single block
      if ( amc_header_info[iAMC].AMCMoreBit &amp;&amp; (!amc_header_info[iAMC].AMCSegBit) )
    {
      blockdatabytes = 32768;
      dbprintf(&quot;M=1,S=0 first block in segment, set size to 0x%08x bytes (odb 0x%08x)\n&quot;, 
           blockdatabytes, amc13_amc13_odb.amc_block_size);
    }
      if ( amc_header_info[iAMC].AMCMoreBit &amp;&amp; amc_header_info[iAMC].AMCSegBit )
    {
      dbprintf(&quot;M=1,S=1 intermediate block in segment, set size from amc header word\n&quot;);
      blockdatabytes = sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;
    }
      if ( (!amc_header_info[iAMC].AMCMoreBit) &amp;&amp; amc_header_info[iAMC].AMCSegBit )
    {
      dbprintf(&quot;M=0,S=1 last block in segment, set size from amc header word\n&quot;);
      blockdatabytes = sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;	  
    }
      if ( (!amc_header_info[iAMC].AMCMoreBit) &amp;&amp; (!amc_header_info[iAMC].AMCSegBit) )
    {
      dbprintf(&quot;M=0,S=0 only block in segment, set size from amc header word\n&quot;);
      blockdatabytes = sizeof(uint64_t)*amc_header_info[iAMC].AMCEventSize;
    }

      // calculated the location to put the data from block structure in AMC13 event
      dataoffset = dataAMCoffset[amc_header_info[iAMC].AMCSlotNum-1] + datablockoffset[amc_header_info[iAMC].AMCSlotNum-1];
      dbprintf(&quot;%s(%d): blockcount %d, iAMC %d, calculated AMC+Block data offset 0x%08x block data bytes 0x%08x data bytes total 0x%08x\n&quot;, 
           __func__, __LINE__, blockcount, iAMC, dataoffset, blockdatabytes, totaldatabytes); 

      // read the data block for each AMC module in array tcp_buf_gl[bufIndex]
      retval  = ReadXBytes( clientsockfd, blockdatabytes, (void*)( tcp_buf_gl[bufIndex] + dataoffset ) ,block_status);
    if ( retval &lt; blockdatabytes) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,blockdatabytes);  
      return -1;                                                                  
    }
      dbprintf(&quot;%s(%d): done reading AMC block %i bytes %i, dataoffset %d, (tcp_buf_gl[bufIndex] + dataoffset ) %p, data[0] 0x%16lx data[1] 0x%16lx\n&quot;, 
           __func__, __LINE__, blockcount, blockdatabytes, dataoffset, ( tcp_buf_gl[bufIndex] + dataoffset ), 
           *( tcp_buf_gl[bufIndex] + dataoffset ), *( tcp_buf_gl[bufIndex] + dataoffset + 1 ) ); 

      //dataoffset += blockdatabytes/sizeof(uint64_t); // redundant so removed?
      datablockoffset[amc_header_info[iAMC].AMCSlotNum-1] += blockdatabytes/sizeof(uint64_t); // datablockoffset[i] is individual payload readout from ith AMC module
      totaldatabytes += blockdatabytes; // totaldatabytes is total payload readout from all AMC modules
      dbprintf(&quot;%s(%d): end of read loop for amc %i\n&quot;,__func__, __LINE__,iAMC);
    }

    // read single 64-bit AMC13 block trailer word
    retval = ReadXBytes( clientsockfd, sizeof(uint64_t), (void*)( offsetamc13info ) ,block_status);
    if ( retval &lt; int(sizeof(uint64_t))) 
      {                                                                                    
    cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,sizeof(uint64_t));  
    return -1;                                                                  
      }
    dbprintf(&quot;%s(%d): done reading AMC block %i, trailer word *tmp 0x%08lx\n&quot;, 
         __func__, __LINE__, blockcount, *offsetamc13info); 

    offsetamc13info++;
    blockcount++;
  }
  dbprintf(&quot;%s(%d): finished data read / unpack, databytes total 0x%08x block count %i\n&quot;, 
       __func__, __LINE__, totaldatabytes, blockcount); 

  // get CDF trailer word
  retval = ReadXBytes( clientsockfd, tailbytes, (void*)(tail) ,block_status);
  if ( retval &lt; int(tailbytes)) 
    {                                                                                    
      cm_msg(MERROR, __FILE__, &quot;Error when reading from socket, fd %d. Read %d bytes vs %d&quot;, clientsockfd,retval,tailbytes);  
      return -1;                                                                  
    }

#ifdef DEBUG
  OverallSize = getOverallSize( be64toh(tail[0]) );
#endif

  dbprintf(&quot;%s(%d): read trailer, trailer size [bytes] %d, tail[0] 0x%016lX, EODdelimiter 0x%016lX, EODmask 0x%016lX, Overall Size %i\n&quot;, 
       __func__, __LINE__, tailbytes, be64toh(tail[0]), EODdelimiter, EODmask, OverallSize);

#if 0 // turn on/off CPU-based byte-reordering in 8-byte AMC13 words 

  // re-order data from network / big-endian to little-endian
  struct timeval tbeforeReorderBytes, tafterReorderBytes;
  gettimeofday( &amp;tbeforeReorderBytes, NULL);

  int iReorderBytes, nReorderBytes = totaldatabytes / sizeof(uint64_t);
  for (iReorderBytes = 0; iReorderBytes &lt; nReorderBytes; iReorderBytes++){
    tcp_buf_gl[bufIndex][iReorderBytes] = be64toh( tcp_buf_gl[bufIndex][iReorderBytes] );
  }

  gettimeofday( &amp;tafterReorderBytes, NULL);
  dbprintf(&quot;%s(%d): duration of byte re-ordering, buffer[%d], fill %d, duration %e us \n&quot;, 
     __func__, __LINE__, bufIndex, TCPfillnumber, toddiff( &amp;tafterReorderBytes, &amp;tbeforeReorderBytes) );
#endif 

  return totaldatabytes;
}</code></pre></div>
</li>
<li>Some checks are made in the main thread:</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"> gettimeofday( &amp;tfinishread, NULL);

    //Test print of the fill number
    //printf(&quot;AMC13 Fill number = %d ; TCP Fill number = %d \n&quot;,getEventIndex( be64toh( header[0] ) ),int(TCPfillnumber));

    //Check if there are data readout correctly
    if (databytes == 0)
    {
      //skip this iteration if there are no data available
      pthread_mutex_unlock( &amp;mutex_TCP_buf[bufIndex] );  
      continue; 
    }

    if (databytes &lt; 0)
    {
      //terminate the while loop if there is an read error
      read_error = true;
      pthread_mutex_unlock( &amp;mutex_TCP_buf[bufIndex] );  
      cm_msg(MERROR, __FILE__,&quot;tcp_thread: break the tcp thread loop becuase of a reading error %d&quot;, databytes);
      break;
    }

    if ( toddiff( &amp;tfinishread, &amp;tbeginread) &gt; 100000.) {
      printf(&quot;WARNING tcpip stall, readAndUnpack &gt; 100ms!&quot;);
      printf(&quot;%s(%d): duration of readAndUnpack, read %d bytes, time = %e us \n&quot;, 
      __func__, __LINE__, databytes , toddiff( &amp;tfinishread, &amp;tbeginread) );
    }

    amc13infobytes = (uint64_t)offsetamc13info - (uint64_t)amc13info; 
    trigger_info.time_tcp_finish_header_read_s = header[3];
    trigger_info.time_tcp_finish_header_read_us = header[4];

    // get time done read / unpack of AMC13 event 
    status = gettimeofday( &amp;tdata, NULL);
    header[5] = tdata.tv_sec; // fill data time info in header
    header[6] = tdata.tv_usec; // fill data time info in header</pre><pre class="hljs"><code> gettimeofday( &amp;tfinishread, NULL);

    //Test print of the fill number
    //printf(&quot;AMC13 Fill number = %d ; TCP Fill number = %d \n&quot;,getEventIndex( be64toh( header[0] ) ),int(TCPfillnumber));

    //Check if there are data readout correctly
    if (databytes == 0)
    {
      //skip this iteration if there are no data available
      pthread_mutex_unlock( &amp;mutex_TCP_buf[bufIndex] );  
      continue; 
    }

    if (databytes &lt; 0)
    {
      //terminate the while loop if there is an read error
      read_error = true;
      pthread_mutex_unlock( &amp;mutex_TCP_buf[bufIndex] );  
      cm_msg(MERROR, __FILE__,&quot;tcp_thread: break the tcp thread loop becuase of a reading error %d&quot;, databytes);
      break;
    }

    if ( toddiff( &amp;tfinishread, &amp;tbeginread) &gt; 100000.) {
      printf(&quot;WARNING tcpip stall, readAndUnpack &gt; 100ms!&quot;);
      printf(&quot;%s(%d): duration of readAndUnpack, read %d bytes, time = %e us \n&quot;, 
      __func__, __LINE__, databytes , toddiff( &amp;tfinishread, &amp;tbeginread) );
    }

    amc13infobytes = (uint64_t)offsetamc13info - (uint64_t)amc13info; 
    trigger_info.time_tcp_finish_header_read_s = header[3];
    trigger_info.time_tcp_finish_header_read_us = header[4];

    // get time done read / unpack of AMC13 event 
    status = gettimeofday( &amp;tdata, NULL);
    header[5] = tdata.tv_sec; // fill data time info in header
    header[6] = tdata.tv_usec; // fill data time info in header</code></pre></div>
</li>
<li><strong>GPU Proc Unlocked - got TCP Header Word 2</strong>
<ol>
<li>Some checks are made to see if data is recieved, variables initialized:</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">//Check TCPfillnumber and makesure TCPfillnumber is greater
unsigned long TCPfillnumber_local;
unsigned long GPUfillnumber_local; //bor function can change the global fill number
unsigned long Midasfillnumber_local;
int local_thread_active = 0;
int local_thread_read = 0;

pthread_mutex_lock( &amp;mutex_TCP_general );
TCPfillnumber_local = TCPfillnumber;
pthread_mutex_unlock( &amp;mutex_TCP_general );

pthread_mutex_lock( &amp;mutex_GPU_general );
GPUfillnumber_local = GPUfillnumber;
local_thread_active = gpu_thread_active;
local_thread_read = gpu_thread_read;
pthread_mutex_unlock( &amp;mutex_GPU_general );

pthread_mutex_lock(&amp;mutex_midas);
Midasfillnumber_local = Midasfillnumber;
pthread_mutex_unlock(&amp;mutex_midas);

if (!local_thread_active)
{
  break;
}

if (!local_thread_read)
{
  usleep(100);
  continue;
}
 if (GPUfillnumber_local == TCPfillnumber_local || TCPfillnumber_local == 0)
    {
      dbprintf(&quot;%s(%d): No new events in the TCP buffer \n&quot;, __func__, __LINE__ );
      usleep(100);
      continue;
    }

    unsigned long tcp_buffer_filled = 0;
    if (TCPfillnumber_local &gt; GPUfillnumber_local)
    {
      tcp_buffer_filled = TCPfillnumber_local - GPUfillnumber_local;
    }else{
      tcp_buffer_filled = 0xffffffffffffffff - (GPUfillnumber_local - TCPfillnumber_local) +1 ;
    }
    dbprintf(&quot;%s(%d): tcp_ring_buffer_size %d \n&quot;, __func__, __LINE__, tcp_buffer_filled );

    dbprintf(&quot;%s(%d): tcp fill %d gpu fill %d \n&quot;, __func__, __LINE__, TCPfillnumber_local , GPUfillnumber_local );

    float BufLoad = tcp_buffer_filled * 1.0 / TCP_BUF_MAX_FILLS;
    float BufLoadThreshold = 0.9;
    if (BufLoad &gt; BufLoadThreshold &amp;&amp; !BufFullAlarmTriggered)
    { 
      BufFullAlarmTriggered = true;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d TCP Ring buffer close to full (%f%%)&quot;,frontend_index,BufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend TCP Buffer Error&quot;, AlarmMsg, &quot;Warning&quot;, &quot;Frontend TCP Buffer Error&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend TCP Buffer Error&quot;     );
      }
    }
    if (BufLoad &lt; BufLoadThreshold &amp;&amp; BufFullAlarmTriggered)
    { 
      BufFullAlarmTriggered = false;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d TCP Ring buffer returns normal (%f%%)&quot;,frontend_index,BufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend TCP Buffer Recovery&quot;, AlarmMsg, &quot;Recovery&quot;, &quot;Frontend TCP Buffer Recovery&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend TCP Buffer Recovery&quot;     );
      }
    }

    unsigned long gpu_buffer_filled = 0;
    if (GPUfillnumber_local &gt; Midasfillnumber_local)
    {
      gpu_buffer_filled = GPUfillnumber_local - Midasfillnumber_local;
    }else{
      gpu_buffer_filled = 0xffffffffffffffff - (Midasfillnumber_local - GPUfillnumber_local) +1 ;
    }
    dbprintf(&quot;%s(%d): gpu_ring_buffer_size %d \n&quot;, __func__, __LINE__, gpu_buffer_filled );

    dbprintf(&quot;%s(%d): gpu fill %d midas fill %d \n&quot;, __func__, __LINE__, GPUfillnumber_local , Midasfillnumber_local );

    float GPUBufLoad = gpu_buffer_filled * 1.0 / GPU_BUFFER_SIZE;
    float GPUBufLoadThreshold = 0.9;
    if (GPUBufLoad &gt; GPUBufLoadThreshold &amp;&amp; !GPUBufFullAlarmTriggered)
    { 
      GPUBufFullAlarmTriggered = true;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d GPU Ring buffer close to full (%f%%)&quot;,frontend_index,GPUBufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend GPU Buffer Error&quot;, AlarmMsg, &quot;Warning&quot;, &quot;Frontend GPU Buffer Error&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend GPU Buffer Error&quot;     );
      }
    }
    if (GPUBufLoad &lt; GPUBufLoadThreshold &amp;&amp; GPUBufFullAlarmTriggered)
    { 
      GPUBufFullAlarmTriggered = false;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d GPU Ring buffer returns normal (%f%%)&quot;,frontend_index,GPUBufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend GPU Buffer Recovery&quot;, AlarmMsg, &quot;Recovery&quot;, &quot;Frontend  GPU Buffer Recovery&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend GPU Buffer Recovery&quot;     );
      }
    }

    //Do not proceed if the GPU buffer is full
    if ( (gpu_buffer_filled &gt;= GPU_BUFFER_SIZE - 1) || (tcp_buffer_filled &gt;= TCP_BUF_MAX_FILLS - 1) )
    {
      fc7help-&gt;setThrottleTriggers( encoder_fc7, frontend_index, 1);
      triggersThrottled = true;
      cm_msg(MINFO, __FILE__, &quot;Requesting Encoder FC7 to throttle TTC triggers to clear TCP/GPU ring buffers&quot;);
      continue;
    } else if ( triggersThrottled ) {
      fc7help-&gt;setThrottleTriggers( encoder_fc7, frontend_index, 0);
      triggersThrottled = false;
      cm_msg(MINFO, __FILE__, &quot;Trigger throttling removed&quot;);
    }

    // calculate TCP ring buffer index from GPU fill number
    TCPbufferindex = GPUfillnumber_local%TCP_BUF_MAX_FILLS;
    dbprintf(&quot;%s(%d): start new fill %d, buffer %d\n&quot;, __func__, __LINE__, GPUfillnumber_local, TCPbufferindex );

    // calculate the GPU ring buffer index 
    GPUbufferindex = GPUfillnumber_local % GPU_BUFFER_SIZE;

    //Lock GPU buffer unit
    pthread_mutex_lock( &amp;mutex_GPU_buf[GPUbufferindex] );
    dbprintf(&quot;%s(%d): got lock to write to GPU buffers %d, \n&quot;, 
    __func__, __LINE__, GPUbufferindex  );

    // get start time for GPU thread processing
    gettimeofday( &amp;tstart, NULL);
    trigger_info.time_gputhread_started_s = tstart.tv_sec; 
    trigger_info.time_gputhread_started_us = tstart.tv_usec; 
    //These has to be done after the memory copy
    //TODO: Check DATA 
    //GPU_Data_Buffer[GPUbufferindex].gpu_data_header[7] = tstart.tv_sec; 
    //GPU_Data_Buffer[GPUbufferindex].gpu_data_header[8] = tstart.tv_usec; 

    // use lock to access the tcp_thread buffers - tcp_buf_gl[i], tcp_buf_header_gl[i], tcp_buf_tail_gl[i]
    pthread_mutex_lock( &amp;mutex_TCP_buf[TCPbufferindex] );
    dbprintf(&quot;%s(%d): got lock to read from TCP output buffers, *tcp_buf_header_gl[%d] = 0x%08x\n&quot;, 
    __func__, __LINE__, TCPbufferindex, be32toh ( *tcp_buf_header_gl[TCPbufferindex] )  );

    // get AMC13 event index from data header ( ugly fix for 64-bit AMC words )
#ifdef DEBUG
    AMC13fillcounter = ( be32toh ( *tcp_buf_header_gl[TCPbufferindex] ) &amp; 0x00FFFFFF ); 
#endif

#ifdef USE_GPU 
#ifdef TIME_MEASURE_DEF 
    cudaEvent_t start, stop;
    float elapsedTime;
    cudaEventCreate(&amp;start);
    cudaEventCreate(&amp;stop);
    cudaEventRecord(start, 0);
#endif // USE_GPU
#endif // TIME_MEASURE_DEF

    dbprintf(&quot;%s(%d): got lock to write to GPU output buffers, fill %d\n&quot;, __func__, __LINE__, GPUfillnumber_local);

    // set GPU_thread data sizes from TCP_thread data sizes and ODB parameters 
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13_size = TCPtotalamc13infosize[TCPbufferindex]; // AMC13 headers / trailers
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header_size = TCPtotalheadersize[TCPbufferindex]; // timing / performance data
    GPU_Data_Buffer[GPUbufferindex].gpu_data_tail_size = TCPtotaltailsize[TCPbufferindex]; // CDF 64-bit trailer word
    GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size = TCPtotaldatasize[TCPbufferindex]; // raw, unpacked AMC payload

    // copy header, trailer amc13info for every fill
    memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_header, tcp_buf_header_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_header_size );
    //Add the GPU processing start time stamp
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header[7] = tstart.tv_sec; 
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header[8] = tstart.tv_usec; </pre><pre class="hljs"><code>//Check TCPfillnumber and makesure TCPfillnumber is greater
unsigned long TCPfillnumber_local;
unsigned long GPUfillnumber_local; //bor function can change the global fill number
unsigned long Midasfillnumber_local;
int local_thread_active = 0;
int local_thread_read = 0;

pthread_mutex_lock( &amp;mutex_TCP_general );
TCPfillnumber_local = TCPfillnumber;
pthread_mutex_unlock( &amp;mutex_TCP_general );

pthread_mutex_lock( &amp;mutex_GPU_general );
GPUfillnumber_local = GPUfillnumber;
local_thread_active = gpu_thread_active;
local_thread_read = gpu_thread_read;
pthread_mutex_unlock( &amp;mutex_GPU_general );

pthread_mutex_lock(&amp;mutex_midas);
Midasfillnumber_local = Midasfillnumber;
pthread_mutex_unlock(&amp;mutex_midas);

if (!local_thread_active)
{
  break;
}

if (!local_thread_read)
{
  usleep(100);
  continue;
}
 if (GPUfillnumber_local == TCPfillnumber_local || TCPfillnumber_local == 0)
    {
      dbprintf(&quot;%s(%d): No new events in the TCP buffer \n&quot;, __func__, __LINE__ );
      usleep(100);
      continue;
    }

    unsigned long tcp_buffer_filled = 0;
    if (TCPfillnumber_local &gt; GPUfillnumber_local)
    {
      tcp_buffer_filled = TCPfillnumber_local - GPUfillnumber_local;
    }else{
      tcp_buffer_filled = 0xffffffffffffffff - (GPUfillnumber_local - TCPfillnumber_local) +1 ;
    }
    dbprintf(&quot;%s(%d): tcp_ring_buffer_size %d \n&quot;, __func__, __LINE__, tcp_buffer_filled );

    dbprintf(&quot;%s(%d): tcp fill %d gpu fill %d \n&quot;, __func__, __LINE__, TCPfillnumber_local , GPUfillnumber_local );

    float BufLoad = tcp_buffer_filled * 1.0 / TCP_BUF_MAX_FILLS;
    float BufLoadThreshold = 0.9;
    if (BufLoad &gt; BufLoadThreshold &amp;&amp; !BufFullAlarmTriggered)
    { 
      BufFullAlarmTriggered = true;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d TCP Ring buffer close to full (%f%%)&quot;,frontend_index,BufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend TCP Buffer Error&quot;, AlarmMsg, &quot;Warning&quot;, &quot;Frontend TCP Buffer Error&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend TCP Buffer Error&quot;     );
      }
    }
    if (BufLoad &lt; BufLoadThreshold &amp;&amp; BufFullAlarmTriggered)
    { 
      BufFullAlarmTriggered = false;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d TCP Ring buffer returns normal (%f%%)&quot;,frontend_index,BufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend TCP Buffer Recovery&quot;, AlarmMsg, &quot;Recovery&quot;, &quot;Frontend TCP Buffer Recovery&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend TCP Buffer Recovery&quot;     );
      }
    }

    unsigned long gpu_buffer_filled = 0;
    if (GPUfillnumber_local &gt; Midasfillnumber_local)
    {
      gpu_buffer_filled = GPUfillnumber_local - Midasfillnumber_local;
    }else{
      gpu_buffer_filled = 0xffffffffffffffff - (Midasfillnumber_local - GPUfillnumber_local) +1 ;
    }
    dbprintf(&quot;%s(%d): gpu_ring_buffer_size %d \n&quot;, __func__, __LINE__, gpu_buffer_filled );

    dbprintf(&quot;%s(%d): gpu fill %d midas fill %d \n&quot;, __func__, __LINE__, GPUfillnumber_local , Midasfillnumber_local );

    float GPUBufLoad = gpu_buffer_filled * 1.0 / GPU_BUFFER_SIZE;
    float GPUBufLoadThreshold = 0.9;
    if (GPUBufLoad &gt; GPUBufLoadThreshold &amp;&amp; !GPUBufFullAlarmTriggered)
    { 
      GPUBufFullAlarmTriggered = true;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d GPU Ring buffer close to full (%f%%)&quot;,frontend_index,GPUBufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend GPU Buffer Error&quot;, AlarmMsg, &quot;Warning&quot;, &quot;Frontend GPU Buffer Error&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend GPU Buffer Error&quot;     );
      }
    }
    if (GPUBufLoad &lt; GPUBufLoadThreshold &amp;&amp; GPUBufFullAlarmTriggered)
    { 
      GPUBufFullAlarmTriggered = false;
      char AlarmMsg[500];
      sprintf(AlarmMsg,&quot;DAQ | AMC13%03d GPU Ring buffer returns normal (%f%%)&quot;,frontend_index,GPUBufLoad*100);

      int ret_code = al_trigger_alarm(&quot;Frontend GPU Buffer Recovery&quot;, AlarmMsg, &quot;Recovery&quot;, &quot;Frontend  GPU Buffer Recovery&quot;, AT_INTERNAL); 
      if (ret_code != AL_SUCCESS) {
    cm_msg(MERROR, __FILE__, &quot;Failure Raising Alarm: Error %d, Alarm \&quot;%s\&quot;&quot;, ret_code, &quot;Frontend GPU Buffer Recovery&quot;     );
      }
    }

    //Do not proceed if the GPU buffer is full
    if ( (gpu_buffer_filled &gt;= GPU_BUFFER_SIZE - 1) || (tcp_buffer_filled &gt;= TCP_BUF_MAX_FILLS - 1) )
    {
      fc7help-&gt;setThrottleTriggers( encoder_fc7, frontend_index, 1);
      triggersThrottled = true;
      cm_msg(MINFO, __FILE__, &quot;Requesting Encoder FC7 to throttle TTC triggers to clear TCP/GPU ring buffers&quot;);
      continue;
    } else if ( triggersThrottled ) {
      fc7help-&gt;setThrottleTriggers( encoder_fc7, frontend_index, 0);
      triggersThrottled = false;
      cm_msg(MINFO, __FILE__, &quot;Trigger throttling removed&quot;);
    }

    // calculate TCP ring buffer index from GPU fill number
    TCPbufferindex = GPUfillnumber_local%TCP_BUF_MAX_FILLS;
    dbprintf(&quot;%s(%d): start new fill %d, buffer %d\n&quot;, __func__, __LINE__, GPUfillnumber_local, TCPbufferindex );

    // calculate the GPU ring buffer index 
    GPUbufferindex = GPUfillnumber_local % GPU_BUFFER_SIZE;

    //Lock GPU buffer unit
    pthread_mutex_lock( &amp;mutex_GPU_buf[GPUbufferindex] );
    dbprintf(&quot;%s(%d): got lock to write to GPU buffers %d, \n&quot;, 
    __func__, __LINE__, GPUbufferindex  );

    // get start time for GPU thread processing
    gettimeofday( &amp;tstart, NULL);
    trigger_info.time_gputhread_started_s = tstart.tv_sec; 
    trigger_info.time_gputhread_started_us = tstart.tv_usec; 
    //These has to be done after the memory copy
    //TODO: Check DATA 
    //GPU_Data_Buffer[GPUbufferindex].gpu_data_header[7] = tstart.tv_sec; 
    //GPU_Data_Buffer[GPUbufferindex].gpu_data_header[8] = tstart.tv_usec; 

    // use lock to access the tcp_thread buffers - tcp_buf_gl[i], tcp_buf_header_gl[i], tcp_buf_tail_gl[i]
    pthread_mutex_lock( &amp;mutex_TCP_buf[TCPbufferindex] );
    dbprintf(&quot;%s(%d): got lock to read from TCP output buffers, *tcp_buf_header_gl[%d] = 0x%08x\n&quot;, 
    __func__, __LINE__, TCPbufferindex, be32toh ( *tcp_buf_header_gl[TCPbufferindex] )  );

    // get AMC13 event index from data header ( ugly fix for 64-bit AMC words )
#ifdef DEBUG
    AMC13fillcounter = ( be32toh ( *tcp_buf_header_gl[TCPbufferindex] ) &amp; 0x00FFFFFF ); 
#endif

#ifdef USE_GPU 
#ifdef TIME_MEASURE_DEF 
    cudaEvent_t start, stop;
    float elapsedTime;
    cudaEventCreate(&amp;start);
    cudaEventCreate(&amp;stop);
    cudaEventRecord(start, 0);
#endif // USE_GPU
#endif // TIME_MEASURE_DEF

    dbprintf(&quot;%s(%d): got lock to write to GPU output buffers, fill %d\n&quot;, __func__, __LINE__, GPUfillnumber_local);

    // set GPU_thread data sizes from TCP_thread data sizes and ODB parameters 
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13_size = TCPtotalamc13infosize[TCPbufferindex]; // AMC13 headers / trailers
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header_size = TCPtotalheadersize[TCPbufferindex]; // timing / performance data
    GPU_Data_Buffer[GPUbufferindex].gpu_data_tail_size = TCPtotaltailsize[TCPbufferindex]; // CDF 64-bit trailer word
    GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size = TCPtotaldatasize[TCPbufferindex]; // raw, unpacked AMC payload

    // copy header, trailer amc13info for every fill
    memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_header, tcp_buf_header_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_header_size );
    //Add the GPU processing start time stamp
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header[7] = tstart.tv_sec; 
    GPU_Data_Buffer[GPUbufferindex].gpu_data_header[8] = tstart.tv_usec; </code></pre></div>
</li>
</ol>
<p>4.<strong>GPU Copy Done - GPU Proc Unlocked</strong><br>
1. Some cuda memcopies and such:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    dbprintf(&quot;%s(%d): copied header databank  [size=0x%08x], header[0] 0x%08x, readout fill number %d, GPU fill number %d\n&quot;, 
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_size, be32toh(GPU_Data_Buffer[GPUbufferindex].gpu_data_header[0]), AMC13fillcounter, GPUfillnumber_local );
    memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_tail, tcp_buf_tail_gl[TCPbufferindex], TCPtotaltailsize[TCPbufferindex] );
    dbprintf(&quot;%s(%d): copied tail databank  [size=0x%08x], tail[0] 0x%08x, readout fill number %d, GPU fill number %d\n&quot;, 
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_tail_size, be32toh(GPU_Data_Buffer[GPUbufferindex].gpu_data_tail[0]), AMC13fillcounter, GPUfillnumber_local );
    memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13, tcp_buf_amc13_gl[TCPbufferindex], TCPtotalamc13infosize[TCPbufferindex] );
    dbprintf(&quot;%s(%d): copied amc13 databank  [size=0x%08x], amc13[0] 0x%08x, readout fill number %d, GPU fill number %d\n&quot;, 
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13_size, be32toh(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13[0]), AMC13fillcounter, GPUfillnumber_local );

    //  extract / copy rider header / trailer data from raw payload to rider header / trailer array  (call arguments mirror memcpy)
    gettimeofday( &amp;tbeforeextract, NULL);

    GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider_size = extractRiderHeader( GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider, tcp_buf_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size ); 
    dbprintf(&quot;%s(%d): copied rider databank[%d], rider[first] 0x%16lx, rider[last] 0x%16lx, readout fill number %d, GPU fill number %d\n&quot;,
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider_size, *(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider),
    *(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider+(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider_size/sizeof(uint64_t))-1), AMC13fillcounter, GPUfillnumber_local );

    gettimeofday( &amp;tafterextract, NULL);
    dbprintf(&quot;%s(%d): duration of extract and copy of rider headers, fdt = %e us \n&quot;, 
    __func__, __LINE__, toddiff( &amp;tafterextract, &amp;tbeforeextract) );

    // extract the FillType etc from rider header / trailers words 
    int indexModHeaderWord2 = 1; // using module header word
    u_int64_t ModHeader2 = be64toh ( GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider[indexModHeaderWord2] );
    u_int64_t ModUserBitMask = ModUserBitField &lt;&lt; ModUserBitOffset;
    int UserField = ( ( ModHeader2 &amp; ModUserBitMask ) &gt;&gt; ModUserBitOffset  ); // from Rider User Manual, June 17 2015
    int ModFillType = UserField &amp; 0x7;  
    dbprintf(&quot;%s(%d): 64-bit Mod header word 0x%016lx after be64toh 0x%016lx and ModFillType 0x%04x\n&quot;,
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider[indexModHeaderWord2], ModHeader2, ModFillType);

    /*
    // 8/14/2017, TG, skip the identification of the fill length from the channel headers. This won't work
    // for async WFD5s with muon/laser fills and sync WFD5s with async fills.. The calculated variables 
    // ChanFillType and WfrmFillType were only used to verify the fill type extracted from the module header

    int indexChanHeaderWord2 = 3; // using channel header word
    u_int64_t ChanHeader2 = be64toh ( gpu_data_header_rider[indexChanHeaderWord2] );
    u_int64_t ChanFTBitMask = ChanFTBitField &lt;&lt; ChanFTBitOffset;
    int ChanFillType = ( ( ChanHeader2 &amp; ChanFTBitMask ) &gt;&gt; ChanFTBitOffset  ); // from Rider User Manual, June 17 2015
    dbprintf(&quot;%s(%d): 64-bit Chan header word 0x%016lx after be64toh 0x%016lx and chan fill type 0x%04x\n&quot;,
    __func__, __LINE__, gpu_data_header_rider[indexChanHeaderWord2], ChanHeader2, ChanFillType);

    int indexWfrmHeaderWord1 = 4; // using waveform header word
    u_int64_t WfrmHeader1 = be64toh ( gpu_data_header_rider[indexWfrmHeaderWord1] );
    u_int64_t WfrmFTBitMask = WfrmFTBitField &lt;&lt; WfrmFTBitOffset;
    int WfrmFillType = ( ( WfrmHeader1 &amp; WfrmFTBitMask ) &gt;&gt; WfrmFTBitOffset  ); // from Rider User Manual, June 17 2015
    dbprintf(&quot;%s(%d): 64-bit Wfrm header word 0x%016lx after be64toh 0x%016lx and wfrm fill type 0x%04x\n&quot;,
    __func__, __LINE__, gpu_data_header_rider[indexWfrmHeaderWord1], WfrmHeader1, WfrmFillType);
     */

    bool process_laser = false;
    for(int ii=0;ii&lt;4;ii++){
      if(tq_parameters_odb[ii].fill_type==2) process_laser=true;
    }
    // copy raw data for pre-scaled muon fills or always of laser/pededstal type fill 
    //if ( ModFillType&gt;1 || ( amc13_settings_odb.store_raw &amp;&amp; !((AMC13fillcounter-1)%amc13_settings_odb.prescale_raw) ) )

    //printf(&quot;ModFillType = %i, amc13_settings_odb.store_raw = %i, GPUmuonfillnumber = %i\n&quot;,ModFillType, amc13_settings_odb.store_raw, GPUmuonfillnumber);
    //printf(&quot;store_raw = %i, GPUmuonfillnumber = %i, amc13_settings_odb.prescale_raw = %i, check = %i\n&quot;,amc13_settings_odb.store_raw,GPUmuonfillnumber,amc13_settings_odb.prescale_raw,!GPUmuonfillnumber%amc13_settings_odb.prescale_raw ); 
    if ( frontend_index==local_encoder_crate || ModFillType&gt;2 || (ModFillType==2 &amp;&amp; !process_laser) || ( amc13_settings_odb.store_raw &amp;&amp; !GPUmuonfillnumber%amc13_settings_odb.prescale_raw  ) )
    {
      memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_raw, tcp_buf_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size );

      dbprintf(&quot;%s(%d): copied raw databank  [size=0x%08x], raw[0] 0x%04x, raw[1] 0x%04x, raw[2] 0x%04x, raw[3] 0x%04x, readout fill number %d, GPU fill number %d, , GPU muon fill number %d\n&quot;, 
      __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size, *GPU_Data_Buffer[GPUbufferindex].gpu_data_raw, *(GPU_Data_Buffer[GPUbufferindex].gpu_data_raw+1), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_raw+2), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_raw+3), AMC13fillcounter, GPUfillnumber_local, GPUmuonfillnumber );
    }

#ifdef USE_GPU  

    // for muon type fill and any TQ processing switched on copy data to GPU 
    if ( (ModFillType==1 || (ModFillType==2 &amp;&amp; process_laser)) &amp;&amp; Any_processing_on ) {

      if ( GPU_IBUF_SIZE &lt; GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size )
      {
    printf(&quot;%s(%d): fill is too large (%d bytes) for GPU buffer (%d bytes) \n&quot;, 
        __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size, GPU_IBUF_SIZE );
    GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size = 1;
      }      

      dbprintf(&quot;%s(%d): *** GPU input data[0], data[0]: %li %li total size %d\n&quot;, 
      __func__, __LINE__, *(tcp_buf_gl[TCPbufferindex]), *(tcp_buf_gl[TCPbufferindex]), GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size);

      // copy raw AMC payload data to GPU
      cudaCopyStatus = cudaMemcpy( gpu_idata, tcp_buf_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size,  cudaMemcpyHostToDevice);
      if ( cudaCopyStatus != cudaSuccess )
      {
    printf(&quot;cudaMemcpy of input data FAIL, status: %d error: %s bytes: %d\n&quot;, cudaCopyStatus, cudaGetErrorString(cudaCopyStatus), GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size);
    if ( cudaCopyStatus == cudaErrorInvalidValue  ) printf(&quot;cudaErrorInvalidValue !\n&quot;);
    if ( cudaCopyStatus == cudaErrorInvalidDevicePointer ) printf(&quot;cudaErrorInvalidDevicePointer!\n&quot;);
      }

#ifdef TIME_MEASURE_DEF
      cudaEventRecord(stop, 0);
      cudaEventSynchronize(stop);
      cudaEventElapsedTime(&amp;elapsedTime, start, stop);
      dbprintf(&quot;%s(%d): copied data from CPU (pntr %p) to GPU (pntr %p), size %d, time %f ms\n&quot;,
      __func__, __LINE__, tcp_buf_gl[TCPbufferindex], gpu_idata, GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size, elapsedTime);
      cudaEventDestroy(start);
      cudaEventDestroy(stop);
#endif // TIME_MEASURE_DEF	
    } // end cuda copy from host to device (if Any_processing_on is true)

    // get GPU copy time for GPU thread
    gettimeofday( &amp;tcopy, NULL);
    dbprintf(&quot;%s(%d): duration of start to copy, fdt = %e us \n&quot;, __func__, __LINE__, toddiff( &amp;tstart, &amp;tcopy) );
    trigger_info.time_gputhread_copytogpu_done_s = tcopy.tv_sec;
    trigger_info.time_gputhread_copytogpu_done_us = tcopy.tv_usec;  </pre><pre class="hljs"><code>    dbprintf(&quot;%s(%d): copied header databank  [size=0x%08x], header[0] 0x%08x, readout fill number %d, GPU fill number %d\n&quot;, 
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_size, be32toh(GPU_Data_Buffer[GPUbufferindex].gpu_data_header[0]), AMC13fillcounter, GPUfillnumber_local );
    memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_tail, tcp_buf_tail_gl[TCPbufferindex], TCPtotaltailsize[TCPbufferindex] );
    dbprintf(&quot;%s(%d): copied tail databank  [size=0x%08x], tail[0] 0x%08x, readout fill number %d, GPU fill number %d\n&quot;, 
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_tail_size, be32toh(GPU_Data_Buffer[GPUbufferindex].gpu_data_tail[0]), AMC13fillcounter, GPUfillnumber_local );
    memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13, tcp_buf_amc13_gl[TCPbufferindex], TCPtotalamc13infosize[TCPbufferindex] );
    dbprintf(&quot;%s(%d): copied amc13 databank  [size=0x%08x], amc13[0] 0x%08x, readout fill number %d, GPU fill number %d\n&quot;, 
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13_size, be32toh(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_amc13[0]), AMC13fillcounter, GPUfillnumber_local );

    //  extract / copy rider header / trailer data from raw payload to rider header / trailer array  (call arguments mirror memcpy)
    gettimeofday( &amp;tbeforeextract, NULL);

    GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider_size = extractRiderHeader( GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider, tcp_buf_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size ); 
    dbprintf(&quot;%s(%d): copied rider databank[%d], rider[first] 0x%16lx, rider[last] 0x%16lx, readout fill number %d, GPU fill number %d\n&quot;,
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider_size, *(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider),
    *(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider+(GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider_size/sizeof(uint64_t))-1), AMC13fillcounter, GPUfillnumber_local );

    gettimeofday( &amp;tafterextract, NULL);
    dbprintf(&quot;%s(%d): duration of extract and copy of rider headers, fdt = %e us \n&quot;, 
    __func__, __LINE__, toddiff( &amp;tafterextract, &amp;tbeforeextract) );

    // extract the FillType etc from rider header / trailers words 
    int indexModHeaderWord2 = 1; // using module header word
    u_int64_t ModHeader2 = be64toh ( GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider[indexModHeaderWord2] );
    u_int64_t ModUserBitMask = ModUserBitField &lt;&lt; ModUserBitOffset;
    int UserField = ( ( ModHeader2 &amp; ModUserBitMask ) &gt;&gt; ModUserBitOffset  ); // from Rider User Manual, June 17 2015
    int ModFillType = UserField &amp; 0x7;  
    dbprintf(&quot;%s(%d): 64-bit Mod header word 0x%016lx after be64toh 0x%016lx and ModFillType 0x%04x\n&quot;,
    __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_header_rider[indexModHeaderWord2], ModHeader2, ModFillType);

    /*
    // 8/14/2017, TG, skip the identification of the fill length from the channel headers. This won't work
    // for async WFD5s with muon/laser fills and sync WFD5s with async fills.. The calculated variables 
    // ChanFillType and WfrmFillType were only used to verify the fill type extracted from the module header

    int indexChanHeaderWord2 = 3; // using channel header word
    u_int64_t ChanHeader2 = be64toh ( gpu_data_header_rider[indexChanHeaderWord2] );
    u_int64_t ChanFTBitMask = ChanFTBitField &lt;&lt; ChanFTBitOffset;
    int ChanFillType = ( ( ChanHeader2 &amp; ChanFTBitMask ) &gt;&gt; ChanFTBitOffset  ); // from Rider User Manual, June 17 2015
    dbprintf(&quot;%s(%d): 64-bit Chan header word 0x%016lx after be64toh 0x%016lx and chan fill type 0x%04x\n&quot;,
    __func__, __LINE__, gpu_data_header_rider[indexChanHeaderWord2], ChanHeader2, ChanFillType);

    int indexWfrmHeaderWord1 = 4; // using waveform header word
    u_int64_t WfrmHeader1 = be64toh ( gpu_data_header_rider[indexWfrmHeaderWord1] );
    u_int64_t WfrmFTBitMask = WfrmFTBitField &lt;&lt; WfrmFTBitOffset;
    int WfrmFillType = ( ( WfrmHeader1 &amp; WfrmFTBitMask ) &gt;&gt; WfrmFTBitOffset  ); // from Rider User Manual, June 17 2015
    dbprintf(&quot;%s(%d): 64-bit Wfrm header word 0x%016lx after be64toh 0x%016lx and wfrm fill type 0x%04x\n&quot;,
    __func__, __LINE__, gpu_data_header_rider[indexWfrmHeaderWord1], WfrmHeader1, WfrmFillType);
     */

    bool process_laser = false;
    for(int ii=0;ii&lt;4;ii++){
      if(tq_parameters_odb[ii].fill_type==2) process_laser=true;
    }
    // copy raw data for pre-scaled muon fills or always of laser/pededstal type fill 
    //if ( ModFillType&gt;1 || ( amc13_settings_odb.store_raw &amp;&amp; !((AMC13fillcounter-1)%amc13_settings_odb.prescale_raw) ) )

    //printf(&quot;ModFillType = %i, amc13_settings_odb.store_raw = %i, GPUmuonfillnumber = %i\n&quot;,ModFillType, amc13_settings_odb.store_raw, GPUmuonfillnumber);
    //printf(&quot;store_raw = %i, GPUmuonfillnumber = %i, amc13_settings_odb.prescale_raw = %i, check = %i\n&quot;,amc13_settings_odb.store_raw,GPUmuonfillnumber,amc13_settings_odb.prescale_raw,!GPUmuonfillnumber%amc13_settings_odb.prescale_raw ); 
    if ( frontend_index==local_encoder_crate || ModFillType&gt;2 || (ModFillType==2 &amp;&amp; !process_laser) || ( amc13_settings_odb.store_raw &amp;&amp; !GPUmuonfillnumber%amc13_settings_odb.prescale_raw  ) )
    {
      memcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_raw, tcp_buf_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size );

      dbprintf(&quot;%s(%d): copied raw databank  [size=0x%08x], raw[0] 0x%04x, raw[1] 0x%04x, raw[2] 0x%04x, raw[3] 0x%04x, readout fill number %d, GPU fill number %d, , GPU muon fill number %d\n&quot;, 
      __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size, *GPU_Data_Buffer[GPUbufferindex].gpu_data_raw, *(GPU_Data_Buffer[GPUbufferindex].gpu_data_raw+1), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_raw+2), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_raw+3), AMC13fillcounter, GPUfillnumber_local, GPUmuonfillnumber );
    }

#ifdef USE_GPU  

    // for muon type fill and any TQ processing switched on copy data to GPU 
    if ( (ModFillType==1 || (ModFillType==2 &amp;&amp; process_laser)) &amp;&amp; Any_processing_on ) {

      if ( GPU_IBUF_SIZE &lt; GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size )
      {
    printf(&quot;%s(%d): fill is too large (%d bytes) for GPU buffer (%d bytes) \n&quot;, 
        __func__, __LINE__, GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size, GPU_IBUF_SIZE );
    GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size = 1;
      }      

      dbprintf(&quot;%s(%d): *** GPU input data[0], data[0]: %li %li total size %d\n&quot;, 
      __func__, __LINE__, *(tcp_buf_gl[TCPbufferindex]), *(tcp_buf_gl[TCPbufferindex]), GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size);

      // copy raw AMC payload data to GPU
      cudaCopyStatus = cudaMemcpy( gpu_idata, tcp_buf_gl[TCPbufferindex], GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size,  cudaMemcpyHostToDevice);
      if ( cudaCopyStatus != cudaSuccess )
      {
    printf(&quot;cudaMemcpy of input data FAIL, status: %d error: %s bytes: %d\n&quot;, cudaCopyStatus, cudaGetErrorString(cudaCopyStatus), GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size);
    if ( cudaCopyStatus == cudaErrorInvalidValue  ) printf(&quot;cudaErrorInvalidValue !\n&quot;);
    if ( cudaCopyStatus == cudaErrorInvalidDevicePointer ) printf(&quot;cudaErrorInvalidDevicePointer!\n&quot;);
      }

#ifdef TIME_MEASURE_DEF
      cudaEventRecord(stop, 0);
      cudaEventSynchronize(stop);
      cudaEventElapsedTime(&amp;elapsedTime, start, stop);
      dbprintf(&quot;%s(%d): copied data from CPU (pntr %p) to GPU (pntr %p), size %d, time %f ms\n&quot;,
      __func__, __LINE__, tcp_buf_gl[TCPbufferindex], gpu_idata, GPU_Data_Buffer[GPUbufferindex].gpu_data_raw_size, elapsedTime);
      cudaEventDestroy(start);
      cudaEventDestroy(stop);
#endif // TIME_MEASURE_DEF	
    } // end cuda copy from host to device (if Any_processing_on is true)

    // get GPU copy time for GPU thread
    gettimeofday( &amp;tcopy, NULL);
    dbprintf(&quot;%s(%d): duration of start to copy, fdt = %e us \n&quot;, __func__, __LINE__, toddiff( &amp;tstart, &amp;tcopy) );
    trigger_info.time_gputhread_copytogpu_done_s = tcopy.tv_sec;
    trigger_info.time_gputhread_copytogpu_done_us = tcopy.tv_usec;  </code></pre></div>
<ol start="5">
<li><strong>GPU Proc Done - GPU Copy Done</strong>
<ol>
<li>Cuda memcopy</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#endif // USE_GPU 

    // unlocked the access to TCP buffer now all data is copied to GPU buffers
    pthread_mutex_unlock( &amp;mutex_TCP_buf[TCPbufferindex]);
    dbprintf(&quot;%s(%d): unlocking ring buffer , buffer %d, fill %d\n&quot;,  __func__, __LINE__, TCPbufferindex, GPUfillnumber_local);

#ifdef USE_GPU  

    // for muon type fill and TQ processing switched on launch processing on GPU 
    if ( ModFillType==1 || ModFillType==2) {

      for (int itq = 0; itq &lt; TQMETHOD_MAX; itq++){

    if ( tq_parameters_odb[itq].TQ_on || tq_parameters_odb[itq].store_hist ) {
      if(tq_parameters_odb[itq].fill_type != ModFillType) continue;

      cuda_g2_run_kernel( gpu_idata, gpu_odata, GPU_Data_Buffer[GPUbufferindex].gpu_data_proc[itq], itq , GPUbufferindex); // see kernel.cu for gpu proceesing functions

      // note that copy from device to host of processed data gpu_data_proc and setting of data size gpu_data_proc_size is done 
      // in  function cuda_g2_run_kernel() whereas the copying and zeroing of histogram data on pre-scaled fills is done here.
      //if (  tq_parameters_odb[itq].store_hist &amp;&amp; !((AMC13fillcounter-1)%tq_parameters_odb[itq].flush_hist) ) 
      if (  tq_parameters_odb[itq].store_hist &amp;&amp; ((GPUmuonfillnumber+1)%tq_parameters_odb[itq].flush_hist)==0 ) {

        // copy histogram data
        cudaCopyStatus = cudaMemcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq], gpu_odata+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq], GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq], cudaMemcpyDeviceToHost); 
        if (cudaCopyStatus !=  cudaSuccess )
        {
          printf(&quot;cudaMemcpy of output data FAIL, status: %d error: %s bytes: %d\n&quot;,
          cudaCopyStatus, cudaGetErrorString(cudaCopyStatus), GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]);
          if ( cudaCopyStatus == cudaErrorInvalidValue  ) printf(&quot;cudaErrorInvalidValue !\n&quot;);
          if ( cudaCopyStatus == cudaErrorInvalidDevicePointer ) printf(&quot;cudaErrorInvalidDevicePointer!\n&quot;);
        }

        dbprintf(&quot;%s(%d): TQ=%i, gpu_odata %p, copying / zeroing hist databank [ size=%d, offset=%d], hist[0] 0x%08x, hist[N/8] 0x%08x, hist[N/4] 0x%08x, readout fill number %d, GPU fill number %d, GPU muon fill number %d\n&quot;,
        __func__, __LINE__, itq, (gpu_odata+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq]), 
        GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq], GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq], *(GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq]), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq]+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]/8+1), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq]+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]/4+1), AMC13fillcounter, GPUfillnumber_local, GPUmuonfillnumber );

        // zero histogram data
        cudaCopyStatus = cudaMemset( gpu_odata+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq], 0, GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]); // size unuts are bytes
        if (cudaCopyStatus !=  cudaSuccess )
        {
          printf(&quot;cudaMemset of histo data FAIL, status: %d error: %s bytes: %d\n&quot;,
          cudaCopyStatus, cudaGetErrorString(cudaCopyStatus), GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]);
          if ( cudaCopyStatus == cudaErrorInvalidValue  ) printf(&quot;cudaErrorInvalidValue !\n&quot;);
          if ( cudaCopyStatus == cudaErrorInvalidDevicePointer ) printf(&quot;cudaErrorInvalidDevicePointer!\n&quot;);
        }


      } // end flush and zero of histogram data

    } // if TQ processing or histogram processing is switched on

      } // loop over index itq of TQ methods  

    } // if muon fill</pre><pre class="hljs"><code>#endif // USE_GPU 

    // unlocked the access to TCP buffer now all data is copied to GPU buffers
    pthread_mutex_unlock( &amp;mutex_TCP_buf[TCPbufferindex]);
    dbprintf(&quot;%s(%d): unlocking ring buffer , buffer %d, fill %d\n&quot;,  __func__, __LINE__, TCPbufferindex, GPUfillnumber_local);

#ifdef USE_GPU  

    // for muon type fill and TQ processing switched on launch processing on GPU 
    if ( ModFillType==1 || ModFillType==2) {

      for (int itq = 0; itq &lt; TQMETHOD_MAX; itq++){

    if ( tq_parameters_odb[itq].TQ_on || tq_parameters_odb[itq].store_hist ) {
      if(tq_parameters_odb[itq].fill_type != ModFillType) continue;

      cuda_g2_run_kernel( gpu_idata, gpu_odata, GPU_Data_Buffer[GPUbufferindex].gpu_data_proc[itq], itq , GPUbufferindex); // see kernel.cu for gpu proceesing functions

      // note that copy from device to host of processed data gpu_data_proc and setting of data size gpu_data_proc_size is done 
      // in  function cuda_g2_run_kernel() whereas the copying and zeroing of histogram data on pre-scaled fills is done here.
      //if (  tq_parameters_odb[itq].store_hist &amp;&amp; !((AMC13fillcounter-1)%tq_parameters_odb[itq].flush_hist) ) 
      if (  tq_parameters_odb[itq].store_hist &amp;&amp; ((GPUmuonfillnumber+1)%tq_parameters_odb[itq].flush_hist)==0 ) {

        // copy histogram data
        cudaCopyStatus = cudaMemcpy( GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq], gpu_odata+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq], GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq], cudaMemcpyDeviceToHost); 
        if (cudaCopyStatus !=  cudaSuccess )
        {
          printf(&quot;cudaMemcpy of output data FAIL, status: %d error: %s bytes: %d\n&quot;,
          cudaCopyStatus, cudaGetErrorString(cudaCopyStatus), GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]);
          if ( cudaCopyStatus == cudaErrorInvalidValue  ) printf(&quot;cudaErrorInvalidValue !\n&quot;);
          if ( cudaCopyStatus == cudaErrorInvalidDevicePointer ) printf(&quot;cudaErrorInvalidDevicePointer!\n&quot;);
        }

        dbprintf(&quot;%s(%d): TQ=%i, gpu_odata %p, copying / zeroing hist databank [ size=%d, offset=%d], hist[0] 0x%08x, hist[N/8] 0x%08x, hist[N/4] 0x%08x, readout fill number %d, GPU fill number %d, GPU muon fill number %d\n&quot;,
        __func__, __LINE__, itq, (gpu_odata+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq]), 
        GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq], GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq], *(GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq]), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq]+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]/8+1), *(GPU_Data_Buffer[GPUbufferindex].gpu_data_his[itq]+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]/4+1), AMC13fillcounter, GPUfillnumber_local, GPUmuonfillnumber );

        // zero histogram data
        cudaCopyStatus = cudaMemset( gpu_odata+GPU_Data_Buffer[GPUbufferindex].gpu_data_his_offset[itq], 0, GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]); // size unuts are bytes
        if (cudaCopyStatus !=  cudaSuccess )
        {
          printf(&quot;cudaMemset of histo data FAIL, status: %d error: %s bytes: %d\n&quot;,
          cudaCopyStatus, cudaGetErrorString(cudaCopyStatus), GPU_Data_Buffer[GPUbufferindex].gpu_data_his_size[itq]);
          if ( cudaCopyStatus == cudaErrorInvalidValue  ) printf(&quot;cudaErrorInvalidValue !\n&quot;);
          if ( cudaCopyStatus == cudaErrorInvalidDevicePointer ) printf(&quot;cudaErrorInvalidDevicePointer!\n&quot;);
        }


      } // end flush and zero of histogram data

    } // if TQ processing or histogram processing is switched on

      } // loop over index itq of TQ methods  

    } // if muon fill</code></pre></div>
</li>
<li><strong>MFE proc unlocked - GPU Proc done</strong>
<ol>
<li>Near beginning of read trigger event</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">INT read_trigger_event(char *pevent, INT off __attribute__((unused)))
{

  int status __attribute__((unused));
  float *fdata;
  BYTE *bdata;
  short *pdata;
  DWORD *hdata;
  char bk_name[8];
  int frontend_index = get_frontend_index();

  // temporary array for performance data to allowing unlocking gpu thread before data compression
  int perf_data_size = 0;
  uint64_t *perf_data;
  perf_data = (uint64_t*) malloc( gpu_data_header_size_max );

  dbprintf(&quot;Begin read_trigger_event!\n&quot;);

  //Obtain the address of the data struct in the GPU buffer
  int GPUbufferindex = Midasfillnumber % GPU_BUFFER_SIZE;
  GPU_Data_t* GPUDATA = &amp;(GPU_Data_Buffer[GPUbufferindex]);

  //Lock the buffer access
  pthread_mutex_lock( &amp;mutex_GPU_buf[GPUbufferindex] );
  // get AMC13 fill number
  unsigned int AMC13fillcounter = ( be32toh ( GPUDATA-&gt;gpu_data_header[0] ) &amp; 0x00FFFFFF ); 

  // get GPU muon fill number that's stored by gpu_thread (used for flushing the CQ, CR banks)
  unsigned int GPUmuonfillcounter = GPUDATA-&gt;gpu_data_header[21];
  dbprintf(&quot;GPUmuonfillcounter %i\n&quot;, GPUmuonfillcounter);

  // get data ready time
  struct timeval t_lock_data, t_got_data;

  status = gettimeofday( &amp;t_lock_data, NULL);
  trigger_info.time_slave_lock_dataready_s  = t_lock_data.tv_sec;
  trigger_info.time_slave_lock_dataready_us = t_lock_data.tv_usec;</pre><pre class="hljs"><code>INT read_trigger_event(char *pevent, INT off __attribute__((unused)))
{

  int status __attribute__((unused));
  float *fdata;
  BYTE *bdata;
  short *pdata;
  DWORD *hdata;
  char bk_name[8];
  int frontend_index = get_frontend_index();

  // temporary array for performance data to allowing unlocking gpu thread before data compression
  int perf_data_size = 0;
  uint64_t *perf_data;
  perf_data = (uint64_t*) malloc( gpu_data_header_size_max );

  dbprintf(&quot;Begin read_trigger_event!\n&quot;);

  //Obtain the address of the data struct in the GPU buffer
  int GPUbufferindex = Midasfillnumber % GPU_BUFFER_SIZE;
  GPU_Data_t* GPUDATA = &amp;(GPU_Data_Buffer[GPUbufferindex]);

  //Lock the buffer access
  pthread_mutex_lock( &amp;mutex_GPU_buf[GPUbufferindex] );
  // get AMC13 fill number
  unsigned int AMC13fillcounter = ( be32toh ( GPUDATA-&gt;gpu_data_header[0] ) &amp; 0x00FFFFFF ); 

  // get GPU muon fill number that's stored by gpu_thread (used for flushing the CQ, CR banks)
  unsigned int GPUmuonfillcounter = GPUDATA-&gt;gpu_data_header[21];
  dbprintf(&quot;GPUmuonfillcounter %i\n&quot;, GPUmuonfillcounter);

  // get data ready time
  struct timeval t_lock_data, t_got_data;

  status = gettimeofday( &amp;t_lock_data, NULL);
  trigger_info.time_slave_lock_dataready_s  = t_lock_data.tv_sec;
  trigger_info.time_slave_lock_dataready_us = t_lock_data.tv_usec;</code></pre></div>
</li>
<li><strong>MFE Banks Made - MFE Proc Unlocked</strong>
<ol>
<li>Bunch of bank construction (too many lines)</li>
</ol>
</li>
<li><strong>lossless compression - MFE Banks Made</strong>
<ol>
<li>lossless data compression, then deletes other banks if compression is on</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">  //This is for run3 and before
  /*
   GPUDATA-&gt;gpu_data_header[19] = TCPfillnumber;
   GPUDATA-&gt;gpu_data_header[20] = GPUfillnumber;
   GPUDATA-&gt;gpu_data_header[21] = GPUmuonfillcounter; // the muon fill counter as set for fill in gpu_thread
   */
  //In Run 4 nothing has to be done here
  //TODO Check Data!

  // fix size of header / timing data
  perf_data_size = 22*sizeof(GPUDATA-&gt;gpu_data_header[0]);
  // perf_data, perf_data_size are copies of GPUDATA-&gt;gpu_data_header, GPUDATA-&gt;gpu_data_header_size in order to release gpu lock before data compression
  memcpy( perf_data, GPUDATA-&gt;gpu_data_header, perf_data_size);



  // unlocking gpu thread access to GPU output buffer (commented out because causing problems)
  pthread_mutex_unlock( &amp;mutex_GPU_buf[GPUbufferindex] );

  // for rider's make losslessly-compressed processed databank 


  dbprintf(&quot;%s(%d): lossless data compression %i\n&quot;, __func__, __LINE__, amc13_settings_odb.lossless_compression);
  if ( amc13_settings_odb.lossless_compression ){
    BANK_HEADER *bank_header = (BANK_HEADER *) pevent;
    dbprintf(&quot;%s(%d): fill FZ data bank, data size %lu\n&quot;,__func__, __LINE__, bank_header-&gt;data_size+sizeof(BANK_HEADER));
    if ( fe_compress_z(pevent, // char pointer to location of output
         (char*)bank_header, // char pointer to location of input
         bank_header-&gt;data_size+sizeof(BANK_HEADER), // data size + header size
         max_event_size-(bank_header-&gt;data_size+sizeof(BANK_HEADER)+sizeof(EVENT_HEADER)), // available space
    0) != FE_SUCCESS ){
      // compression failed. store raw dats
      printf(&quot;%s(%d): fill FZ data bank - compression failed\n&quot;,__func__, __LINE__);
    }

    // if losslessly compressing the midas banks then delete the uncompressed banks

#ifdef USE_GPU	
    for (int itq = 0; itq &lt; TQMETHOD_MAX; itq++){

      if ( tq_parameters_odb[itq].TQ_on &amp;&amp; Fill_type==1 ) {

        sprintf(bk_name,&quot;%sS%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
        sprintf(bk_name,&quot;%sP%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
        sprintf(bk_name,&quot;%sT%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      } // end delete CQ, CP, CT banks

      //if ( tq_parameters_odb[itq].store_hist &amp;&amp; Fill_type==1 &amp;&amp; !( (AMC13fillcounter-1-tq_parameters_odb[itq].flush_offset_hist) % tq_parameters_odb[itq].flush_hist ) )
      // flush offset is disabled for run4, and making sure that fill0 is not flushed.
      if ( tq_parameters_odb[itq].store_hist &amp;&amp; Fill_type==1 &amp;&amp; ( (GPUmuonfillcounter+1) % tq_parameters_odb[itq].flush_hist ) == 0) {

        sprintf(bk_name,&quot;%sQ%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      } // end delete CH bank

      if ( tq_parameters_odb[itq].fit_islands&gt;0 &amp;&amp; Fill_type==1 ){

        sprintf(bk_name,&quot;%sF%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      } // end delete CF bank

    } // end loop over TQ methods
    sprintf(bk_name,&quot;CA000&quot;);
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
    sprintf(bk_name,&quot;CR000&quot;);
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
    sprintf(bk_name,&quot;CZ000&quot;);
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

#endif // USE_GPU


    if (Fill_type&gt;1 || ( amc13_settings_odb.store_raw &amp;&amp; !( ( GPUmuonfillcounter - amc13_settings_odb.prescale_offset_raw ) % amc13_settings_odb.prescale_raw ) &amp;&amp; AMC13fillcounter&gt;=amc13_settings_odb.prescale_offset_raw)) {

      if (Fill_type == 0x1) {
        sprintf(bk_name,&quot;CR%03i&quot;,frontend_index); // muon fill type
      }
      else if(Fill_type == 0x2) {
        sprintf(bk_name,&quot;LR%03i&quot;,frontend_index); // laser fill type
      }
      else if(Fill_type == 0x3) {
        sprintf(bk_name,&quot;PR%03i&quot;,frontend_index); // pedestal fill type
      }
      else if(Fill_type == 0x4) {
        sprintf(bk_name,&quot;AR%03i&quot;,frontend_index); // async fill type
      }
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

    } // end delete CR bank, etc

    // delete CA / LA / PA banks
    if (Fill_type == 0x1) {
      sprintf(bk_name,&quot;CA%03i&quot;,frontend_index); // muon fill type
    }
    else if(Fill_type == 0x2) {
      sprintf(bk_name,&quot;LA%03i&quot;,frontend_index); // laser fill type
    }
    else if(Fill_type == 0x3) {
      sprintf(bk_name,&quot;PA%03i&quot;,frontend_index); // pedestal fill type
    }
    else if(Fill_type == 0x4) {
      sprintf(bk_name,&quot;AA%03i&quot;,frontend_index); // async fill type
    }
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

    // delete CB bank (there's no filling of &quot;CB&quot; bank equivalent for laser, ped, async fills
    if (Fill_type == 0x1) {
      sprintf(bk_name,&quot;CB%03i&quot;,frontend_index); // muon fill type
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
    }

      // delete CC / LC / PC / AC banks
      if (Fill_type == 0x1) {
    sprintf(bk_name,&quot;CC%03i&quot;,frontend_index); // muon fill type
      }
      else if(Fill_type == 0x2) {
    sprintf(bk_name,&quot;LC%03i&quot;,frontend_index); // laser fill type
      }
      else if(Fill_type == 0x3) {
    sprintf(bk_name,&quot;PC%03i&quot;,frontend_index); // pedestal fill type
      }
      else if(Fill_type == 0x4) {
    sprintf(bk_name,&quot;AC%03i&quot;,frontend_index); // async fill type
      }
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      // delete CZ / LZ / PZ / AZ banks
      if (Fill_type == 0x1) {
    sprintf(bk_name,&quot;CZ%03i&quot;,frontend_index); // muon fill type
      }
      else if(Fill_type == 0x2) {
    sprintf(bk_name,&quot;LZ%03i&quot;,frontend_index); // laser fill type
      }
      else if(Fill_type == 0x3) {
    sprintf(bk_name,&quot;PZ%03i&quot;,frontend_index); // pedestal fill type
      }
      else if(Fill_type == 0x4) {
    sprintf(bk_name,&quot;AZ%03i&quot;,frontend_index); // async fill type
      }
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);


  } // end lossless compression
</pre><pre class="hljs"><code>  //This is for run3 and before
  /*
   GPUDATA-&gt;gpu_data_header[19] = TCPfillnumber;
   GPUDATA-&gt;gpu_data_header[20] = GPUfillnumber;
   GPUDATA-&gt;gpu_data_header[21] = GPUmuonfillcounter; // the muon fill counter as set for fill in gpu_thread
   */
  //In Run 4 nothing has to be done here
  //TODO Check Data!

  // fix size of header / timing data
  perf_data_size = 22*sizeof(GPUDATA-&gt;gpu_data_header[0]);
  // perf_data, perf_data_size are copies of GPUDATA-&gt;gpu_data_header, GPUDATA-&gt;gpu_data_header_size in order to release gpu lock before data compression
  memcpy( perf_data, GPUDATA-&gt;gpu_data_header, perf_data_size);



  // unlocking gpu thread access to GPU output buffer (commented out because causing problems)
  pthread_mutex_unlock( &amp;mutex_GPU_buf[GPUbufferindex] );

  // for rider's make losslessly-compressed processed databank 


  dbprintf(&quot;%s(%d): lossless data compression %i\n&quot;, __func__, __LINE__, amc13_settings_odb.lossless_compression);
  if ( amc13_settings_odb.lossless_compression ){
    BANK_HEADER *bank_header = (BANK_HEADER *) pevent;
    dbprintf(&quot;%s(%d): fill FZ data bank, data size %lu\n&quot;,__func__, __LINE__, bank_header-&gt;data_size+sizeof(BANK_HEADER));
    if ( fe_compress_z(pevent, // char pointer to location of output
         (char*)bank_header, // char pointer to location of input
         bank_header-&gt;data_size+sizeof(BANK_HEADER), // data size + header size
         max_event_size-(bank_header-&gt;data_size+sizeof(BANK_HEADER)+sizeof(EVENT_HEADER)), // available space
    0) != FE_SUCCESS ){
      // compression failed. store raw dats
      printf(&quot;%s(%d): fill FZ data bank - compression failed\n&quot;,__func__, __LINE__);
    }

    // if losslessly compressing the midas banks then delete the uncompressed banks

#ifdef USE_GPU	
    for (int itq = 0; itq &lt; TQMETHOD_MAX; itq++){

      if ( tq_parameters_odb[itq].TQ_on &amp;&amp; Fill_type==1 ) {

        sprintf(bk_name,&quot;%sS%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
        sprintf(bk_name,&quot;%sP%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
        sprintf(bk_name,&quot;%sT%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      } // end delete CQ, CP, CT banks

      //if ( tq_parameters_odb[itq].store_hist &amp;&amp; Fill_type==1 &amp;&amp; !( (AMC13fillcounter-1-tq_parameters_odb[itq].flush_offset_hist) % tq_parameters_odb[itq].flush_hist ) )
      // flush offset is disabled for run4, and making sure that fill0 is not flushed.
      if ( tq_parameters_odb[itq].store_hist &amp;&amp; Fill_type==1 &amp;&amp; ( (GPUmuonfillcounter+1) % tq_parameters_odb[itq].flush_hist ) == 0) {

        sprintf(bk_name,&quot;%sQ%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      } // end delete CH bank

      if ( tq_parameters_odb[itq].fit_islands&gt;0 &amp;&amp; Fill_type==1 ){

        sprintf(bk_name,&quot;%sF%03i&quot;, tq_parameters_odb[itq].TQ_bankprefix, frontend_index);
        bk_delete(pevent,bk_name);
        dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      } // end delete CF bank

    } // end loop over TQ methods
    sprintf(bk_name,&quot;CA000&quot;);
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
    sprintf(bk_name,&quot;CR000&quot;);
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
    sprintf(bk_name,&quot;CZ000&quot;);
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

#endif // USE_GPU


    if (Fill_type&gt;1 || ( amc13_settings_odb.store_raw &amp;&amp; !( ( GPUmuonfillcounter - amc13_settings_odb.prescale_offset_raw ) % amc13_settings_odb.prescale_raw ) &amp;&amp; AMC13fillcounter&gt;=amc13_settings_odb.prescale_offset_raw)) {

      if (Fill_type == 0x1) {
        sprintf(bk_name,&quot;CR%03i&quot;,frontend_index); // muon fill type
      }
      else if(Fill_type == 0x2) {
        sprintf(bk_name,&quot;LR%03i&quot;,frontend_index); // laser fill type
      }
      else if(Fill_type == 0x3) {
        sprintf(bk_name,&quot;PR%03i&quot;,frontend_index); // pedestal fill type
      }
      else if(Fill_type == 0x4) {
        sprintf(bk_name,&quot;AR%03i&quot;,frontend_index); // async fill type
      }
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

    } // end delete CR bank, etc

    // delete CA / LA / PA banks
    if (Fill_type == 0x1) {
      sprintf(bk_name,&quot;CA%03i&quot;,frontend_index); // muon fill type
    }
    else if(Fill_type == 0x2) {
      sprintf(bk_name,&quot;LA%03i&quot;,frontend_index); // laser fill type
    }
    else if(Fill_type == 0x3) {
      sprintf(bk_name,&quot;PA%03i&quot;,frontend_index); // pedestal fill type
    }
    else if(Fill_type == 0x4) {
      sprintf(bk_name,&quot;AA%03i&quot;,frontend_index); // async fill type
    }
    bk_delete(pevent,bk_name);
    dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

    // delete CB bank (there's no filling of &quot;CB&quot; bank equivalent for laser, ped, async fills
    if (Fill_type == 0x1) {
      sprintf(bk_name,&quot;CB%03i&quot;,frontend_index); // muon fill type
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);
    }

      // delete CC / LC / PC / AC banks
      if (Fill_type == 0x1) {
    sprintf(bk_name,&quot;CC%03i&quot;,frontend_index); // muon fill type
      }
      else if(Fill_type == 0x2) {
    sprintf(bk_name,&quot;LC%03i&quot;,frontend_index); // laser fill type
      }
      else if(Fill_type == 0x3) {
    sprintf(bk_name,&quot;PC%03i&quot;,frontend_index); // pedestal fill type
      }
      else if(Fill_type == 0x4) {
    sprintf(bk_name,&quot;AC%03i&quot;,frontend_index); // async fill type
      }
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);

      // delete CZ / LZ / PZ / AZ banks
      if (Fill_type == 0x1) {
    sprintf(bk_name,&quot;CZ%03i&quot;,frontend_index); // muon fill type
      }
      else if(Fill_type == 0x2) {
    sprintf(bk_name,&quot;LZ%03i&quot;,frontend_index); // laser fill type
      }
      else if(Fill_type == 0x3) {
    sprintf(bk_name,&quot;PZ%03i&quot;,frontend_index); // pedestal fill type
      }
      else if(Fill_type == 0x4) {
    sprintf(bk_name,&quot;AZ%03i&quot;,frontend_index); // async fill type
      }
      bk_delete(pevent,bk_name);
      dbprintf(&quot;%s(%d): deleted bank %s\n&quot;, __func__, __LINE__, bk_name);


  } // end lossless compression
</code></pre></div>
</li>
</ol>
<hr>
<h2 id="14052024-1219">14/05/2024 12:19</h2>
<p>Scanning the 192.168.xxx.xxx subet with <code class="inline-code">nmap 192.168.0.0/16</code> shows me the VadaTech MCH is here(?):</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">192.168.20.14 &lt;-- Network Research
192.168.20.230 &lt;-- Network Research
192.168.60.15 &lt;-- VadaTech
192.168.60.17 &lt;-- VadaTech
192.168.60.18 &lt;-- VadaTech
192.168.60.19 &lt;-- VadaTech</pre><pre class="hljs"><code><span class="hljs-number">192.168.20.14</span> &lt;-- Network Research
<span class="hljs-number">192.168.20.230</span> &lt;-- Network Research
<span class="hljs-number">192.168.60.15</span> &lt;-- VadaTech
<span class="hljs-number">192.168.60.17</span> &lt;-- VadaTech
<span class="hljs-number">192.168.60.18</span> &lt;-- VadaTech
<span class="hljs-number">192.168.60.19</span> &lt;-- VadaTech</code></pre></div>
<p>For some reason I can't scroll up in the terminal, so I'm a little upset by that, but this is all I can see. Apparently CentOS7 clears the terminal buffer after some time.</p>
<p>In any event, pinging any of the VadaTech modules hangs. The destination is reachable from the 'be' computer's perspective, but there is no response from the modules. I can, however, ping T1 and T2 located at <code class="inline-code">192.168.20.13</code> and <code class="inline-code">192.168.20.14</code>.</p>
<hr>
<h2 id="14052024-1311">14/05/2024 13:11</h2>
<p>For our temporary setup using WiFi, the 'be' computer can be connected to by ssh tunneling. See intructions below:</p>
<p><strong>Remotely connect to newest desktop<br>
Port forward connections for midas, crate monitor, data monitor:</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ssh -L 8080:localhost:8080 -L 8000:localhost:8000 -L 7000:localhost:7000 pioneer@10.47.95.44</pre><pre class="hljs"><code><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">8080</span>:localhost:<span class="hljs-number">8080</span> -L <span class="hljs-number">8000</span>:localhost:<span class="hljs-number">8000</span> -L <span class="hljs-number">7000</span>:localhost:<span class="hljs-number">7000</span> pioneer@<span class="hljs-number">10.47.95.44</span></code></pre></div>
<p><strong>Remotely connect to 'be'<br>
Port forward connections for midas, crate monitor, data monitor:</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ssh -L 8080:localhost:8080 -L 8000:localhost:8000 -L 7000:localhost:7000 root@10.0.0.3</pre><pre class="hljs"><code><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">8080</span>:localhost:<span class="hljs-number">8080</span> -L <span class="hljs-number">8000</span>:localhost:<span class="hljs-number">8000</span> -L <span class="hljs-number">7000</span>:localhost:<span class="hljs-number">7000</span> root@<span class="hljs-number">10.0.0.3</span></code></pre></div>
<p>Passwords for both are <code class="inline-code">mu-&gt;egamma</code></p>
<hr>
<h2 id="14052024-1319">14/05/2024 13:19</h2>
<p>I tested swapping out the MCHs (put N.A.T. MCH in our second crate). I was able to ping the N.A.T. with <code class="inline-code">ping 192.168.1.41</code></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">[root@localhost ~]# ping 192.168.1.41
PING 192.168.1.41 (192.168.1.41) 56(84) bytes of data.
64 bytes from 192.168.1.41: icmp_seq=1 ttl=255 time=0.313 ms
64 bytes from 192.168.1.41: icmp_seq=2 ttl=255 time=0.355 ms</pre><pre class="hljs"><code>[root@localhost ~]#<span class="hljs-built_in"> ping </span>192.168.1.41<span class="hljs-built_in">
PING </span>192.168.1.41 (192.168.1.41) 56(84) bytes of data.
64 bytes <span class="hljs-keyword">from</span> 192.168.1.41: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=255 <span class="hljs-attribute">time</span>=0.313 ms
64 bytes <span class="hljs-keyword">from</span> 192.168.1.41: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=255 <span class="hljs-attribute">time</span>=0.355 ms</code></pre></div>
<hr>
<h2 id="14052024-1337">14/05/2024 13:37</h2>
<p>Here are the untrucated results of <code class="inline-code">nmap 192.168.0.0/16</code>:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">[root@localhost output_files]# cat nmap_output2.txt

Starting Nmap 6.40 ( http://nmap.org ) at 2024-05-14 12:49 EDT
Nmap scan report for 192.168.1.1
Host is up (0.00011s latency).
All 1000 scanned ports on 192.168.1.1 are filtered
MAC Address: 00:60:55:00:01:DF (Cornell University)

Nmap scan report for 192.168.4.3
Host is up (-0.034s latency).
All 1000 scanned ports on 192.168.4.3 are filtered
MAC Address: 00:60:55:00:01:BC (Cornell University)

Nmap scan report for 192.168.1.100
Host is up (0.000031s latency).
Not shown: 997 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
111/tcp  open  rpcbind
2049/tcp open  nfs

Nmap scan report for 192.168.20.13
Host is up (-0.10s latency).
All 1000 scanned ports on 192.168.20.13 are filtered
MAC Address: 08:00:30:F3:04:33 (Network Research)

Nmap scan report for 192.168.20.14
Host is up (0.00011s latency).
All 1000 scanned ports on 192.168.20.14 are filtered
MAC Address: 08:00:30:F3:04:73 (Network Research)

Nmap scan report for 192.168.40.230
Host is up (0.0015s latency).
All 1000 scanned ports on 192.168.40.230 are filtered
MAC Address: 00:13:3A:0A:21:72 (VadaTech)

Nmap scan report for 192.168.60.15
Host is up (0.00092s latency).
All 1000 scanned ports on 192.168.60.15 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.60.17
Host is up (0.0012s latency).
All 1000 scanned ports on 192.168.60.17 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.60.18
Host is up (0.0012s latency).
All 1000 scanned ports on 192.168.60.18 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.60.19
Host is up (0.0011s latency).
All 1000 scanned ports on 192.168.60.19 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.122.1
Host is up (0.000031s latency).
Not shown: 996 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
53/tcp   open  domain
111/tcp  open  rpcbind
2049/tcp open  nfs

Nmap done: 47872 IP addresses (11 hosts up) scanned in 1743.13 seconds
[root@localhost output_files]#</pre><pre class="hljs"><code>[root@localhost output_files]# cat nmap_output2.txt

Starting Nmap 6.40 ( http://nmap.org ) at 2024-05-14 12:49 EDT
Nmap scan report for 192.168.1.1
Host is up (0.00011s latency).
All 1000 scanned ports on 192.168.1.1 are filtered
MAC Address: 00:60:55:00:01:DF (Cornell University)

Nmap scan report for 192.168.4.3
Host is up (-0.034s latency).
All 1000 scanned ports on 192.168.4.3 are filtered
MAC Address: 00:60:55:00:01:BC (Cornell University)

Nmap scan report for 192.168.1.100
Host is up (0.000031s latency).
Not shown: 997 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
111/tcp  open  rpcbind
2049/tcp open  nfs

Nmap scan report for 192.168.20.13
Host is up (-0.10s latency).
All 1000 scanned ports on 192.168.20.13 are filtered
MAC Address: 08:00:30:F3:04:33 (Network Research)

Nmap scan report for 192.168.20.14
Host is up (0.00011s latency).
All 1000 scanned ports on 192.168.20.14 are filtered
MAC Address: 08:00:30:F3:04:73 (Network Research)

Nmap scan report for 192.168.40.230
Host is up (0.0015s latency).
All 1000 scanned ports on 192.168.40.230 are filtered
MAC Address: 00:13:3A:0A:21:72 (VadaTech)

Nmap scan report for 192.168.60.15
Host is up (0.00092s latency).
All 1000 scanned ports on 192.168.60.15 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.60.17
Host is up (0.0012s latency).
All 1000 scanned ports on 192.168.60.17 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.60.18
Host is up (0.0012s latency).
All 1000 scanned ports on 192.168.60.18 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.60.19
Host is up (0.0011s latency).
All 1000 scanned ports on 192.168.60.19 are filtered
MAC Address: 00:13:3A:0A:14:B9 (VadaTech)

Nmap scan report for 192.168.122.1
Host is up (0.000031s latency).
Not shown: 996 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
53/tcp   open  domain
111/tcp  open  rpcbind
2049/tcp open  nfs

Nmap done: 47872 IP addresses (11 hosts up) scanned in 1743.13 seconds
[root@localhost output_files]#</code></pre></div>
<hr>
<h2 id="14052024-1516">14/05/2024 15:16</h2>
<p>I tried to connect to Vadatech MCH webpage on the newest desktop with it connected to 'be' which is connected to the VadaTech MCH:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ssh -L 8081:192.168.40.230:80 root@10.0.0.3</pre><pre class="hljs"><code><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">8081</span>:<span class="hljs-number">192.168.40.230:80</span> root@<span class="hljs-number">10.0.0.3</span></code></pre></div>
<p>Then going to localhost:8081 should bring up the webpage, but it just hangs. It's unclear to me what the port 80 does at the end of the -L flag parameter (though this worked for the N.A.T. MCH).</p>
<p>I then tried to remove 'be' as the middle man. I reconfigured the network settings on the newest desktop so it is on the 192.168.xxx.xxx network and directly connected it to the MCH GbE0 port. I was able to ping T1, T2, and the 2 WFD5s in the crate, so the connection &quot;worked.&quot; But I have all the same problems as before (can't see webpage by going to <a data-from-md title='http://192.168.40.230/' href='http://192.168.40.230/'>http://192.168.40.230/</a>, can't ping MCH, etc.)</p>
<hr>
<h2 id="14052024-1649">14/05/2024 16:49</h2>
<p>I was able to get into the MCH by setting the computer's IP to 192.168.60.xxx.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#
# Connect to MCH
#
TYPE=Ethernet
BOOTPROTO=static
IPADDR=192.168.60.100
NETMASK=255.255.0.0
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
NAME=enp5s0
DEVICE=enp5s0
ONBOOT=yes</pre><pre class="hljs"><code><span class="hljs-comment">#</span>
<span class="hljs-comment"># Connect to MCH</span>
<span class="hljs-comment">#</span>
<span class="hljs-attr">TYPE</span>=Ethernet
<span class="hljs-attr">BOOTPROTO</span>=static
<span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">60.100</span>
<span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">0.0</span>
<span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERDNS</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERROUTES</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">NAME</span>=enp5s0
<span class="hljs-attr">DEVICE</span>=enp5s0
<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span></code></pre></div>
<p>It turns out our MCH was configured to ignore traffic outside of the <code class="inline-code">255.255.254.0</code> = 192.168.60.xxx subnet, as you can see when doing <code class="inline-code">vim /etc/rc.d/rc.conf</code></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"># net interface 0
export SYSCFG_IFACE0=n
export INTERFACE0=&quot;eth0&quot;
export IPADDR0=&quot;0.0.0.0&quot;
export NETMASK0=&quot;0.0.0.0&quot;
export BROADCAST0=&quot;0.0.0.0&quot;
export GATEWAY0=&quot;0.0.0.0&quot;
export NAMESERVER0=&quot;0.0.0.0&quot;
# net interface 1
export SYSCFG_IFACE1=y
export INTERFACE1=&quot;eth1&quot;
export IPADDR1=&quot;192.168.60.15&quot;
export NETMASK1=&quot;255.255.254.0&quot;
export BROADCAST1=&quot;192.168.61.255&quot;
export GATEWAY1=&quot;192.168.60.121&quot;
export NAMESERVER1=&quot;0.0.0.0&quot;</pre><pre class="hljs"><code><span class="hljs-comment"># net interface 0</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">SYSCFG_IFACE0</span>=n
<span class="hljs-built_in">export</span> <span class="hljs-attribute">INTERFACE0</span>=<span class="hljs-string">&quot;eth0&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">IPADDR0</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">NETMASK0</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">BROADCAST0</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">GATEWAY0</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">NAMESERVER0</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>
<span class="hljs-comment"># net interface 1</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">SYSCFG_IFACE1</span>=y
<span class="hljs-built_in">export</span> <span class="hljs-attribute">INTERFACE1</span>=<span class="hljs-string">&quot;eth1&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">IPADDR1</span>=<span class="hljs-string">&quot;192.168.60.15&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">NETMASK1</span>=<span class="hljs-string">&quot;255.255.254.0&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">BROADCAST1</span>=<span class="hljs-string">&quot;192.168.61.255&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">GATEWAY1</span>=<span class="hljs-string">&quot;192.168.60.121&quot;</span>
<span class="hljs-built_in">export</span> <span class="hljs-attribute">NAMESERVER1</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span></code></pre></div>
<p>To edit files, you have to run:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">mount -o remount,rw /</pre><pre class="hljs"><code><span class="hljs-attribute">mount</span> -o remount,rw /</code></pre></div>
<p>Also, for some reason to use vim on the MCH you have to run:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">:set nocompatible</pre><pre class="hljs"><code>:<span class="hljs-built_in">set</span> nocompatible</code></pre></div>
<p>first.</p>
<hr>
<h2 id="14052024-1655">14/05/2024 16:55</h2>
<p>I was able to edit the MCH to change it's crate number to &quot;2&quot; by following the steps in this pdf.<br>
<a data-from-md title='../_resources/7310fd91309c42a6a62d700a2187fc40.pdf' href='../_resources/7310fd91309c42a6a62d700a2187fc40.pdf'>mch_network_configuration.pdf</a></p>
<hr>
<h2 id="14052024-1736">14/05/2024 17:36</h2>
<p>Before I solved the problem with the 10GbE link by putting the 10GbE AMC port on a different subnet (192.168.1.150). However, this will no longer work with two crates. In short, it's against subnetting rules to have a subnet like 192.168.{1 or 2}.{1 to 128} or anything similar. Basically, you can't have control over the 3rd and 4th octet simulatenously.</p>
<p>As a result, I need to find a way to get the 10GbE link on a different subnet (i.e 192.168.50.xxx, or something like that). I failed to do this before, and I'm unsure why it didn't work. I didn't test too thoroughly</p>
<blockquote>
<h3 id="27032024-2038">27/03/2024 20:38</h3>
<p>I am trying to change the IP to 192.168.10.1</p>
<p>Pick an action (h for menu): wv 0x1c1c 0xc0a80a01<br>
Writing to T1:<br>
00001c1c: c0a80a01</p>
<p>Pick an action (h for menu): rv 0x1c1c<br>
Reading T1:<br>
00001c1c: c0a80a01<br>
since</p>
<p>192 = c0<br>
168 = a8<br>
10  = 0a<br>
1   = 01<br>
I then changed enp1s0f1 to be on the 192.168.10.xxx subnet with IP 192.168.1.2. It didn't really seem to work:</p>
<p>[root@dhcp-10-163-105-238 amc13StandaloneMAN_2014-05-12]# ping 192.168.10.1<br>
PING 192.168.10.1 (192.168.10.1) 56(84) bytes of data.<br>
^C<br>
--- 192.168.10.1 ping statistics ---<br>
2 packets transmitted, 0 received, 100% packet loss, time 999ms</p>
<p>[root@dhcp-10-163-105-238 amc13StandaloneMAN_2014-05-12]# ifdown enp5s0<br>
Device 'enp5s0' successfully disconnected.<br>
[root@dhcp-10-163-105-238 amc13StandaloneMAN_2014-05-12]# ping 192.168.10.1<br>
PING 192.168.10.1 (192.168.10.1) 56(84) bytes of data.<br>
^C<br>
--- 192.168.10.1 ping statistics ---<br>
1 packets transmitted, 0 received, 100% packet loss, time 0ms</p>
<p>[root@dhcp-10-163-105-238 amc13StandaloneMAN_2014-05-12]#<br>
I can successfully change the IP to something else on the 192.168.1.xxx subnet though</p>
</blockquote>
<hr>
<h2 id="15052024-1218">15/05/2024 12:18</h2>
<p>I don't know what I was doing wrong last time. I got the 10GbE links to work rather trivially this time.</p>
<p>First I change the network settings scripts for the 10GbE ports on 'be'. I set them to be on the networks 192.168.50.xxx and 192.168.51.xxx. enp1s0f1 is connected to crate 1, and enp1s0f0 is connected to crate 2, so we have to set the 10GbE port addresses to be on the respective network.<br>
<strong>/etc/sysconfig/network-scripts/ifcfg-enp1s0f0:</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#
# Connect to AMC
#
TYPE=Ethernet
BOOTPROTO=static
IPADDR=192.168.51.100
NETMASK=255.255.255.0
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
NAME=enp1s0f0
DEVICE=enp1s0f0
ONBOOT=yes
AUTOCONNECT_PRIORITY=-999
MTU=9000</pre><pre class="hljs"><code><span class="hljs-comment">#</span>
<span class="hljs-comment"># Connect to AMC</span>
<span class="hljs-comment">#</span>
<span class="hljs-attr">TYPE</span>=Ethernet
<span class="hljs-attr">BOOTPROTO</span>=static
<span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">51.100</span>
<span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>
<span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERDNS</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_PEERROUTES</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">NAME</span>=enp1s0f0
<span class="hljs-attr">DEVICE</span>=enp1s0f0
<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">AUTOCONNECT_PRIORITY</span>=-<span class="hljs-number">999</span>
<span class="hljs-attr">MTU</span>=<span class="hljs-number">9000</span></code></pre></div>
<p><strong>/etc/sysconfig/network-scripts/ifcfg-enp1s0f1:</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#
# Connect to AMC
#
HWADDR=b4:b5:2f:a4:e7:fc
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=none
IPADDR=192.168.50.100
NETMASK=255.255.255.0
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
UUID=f1d52da3-687b-3215-a2c0-60c11d0fd3bf
ONBOOT=yes
AUTOCONNECT_PRIORITY=-999
MTU=9000
DEVICE=enp1s0f1
NAME=enp1s0f1</pre><pre class="hljs"><code><span class="hljs-comment">#</span>
<span class="hljs-comment"># Connect to AMC</span>
<span class="hljs-comment">#</span>
<span class="hljs-attr">HWADDR</span>=b4:b5:<span class="hljs-number">2</span>f:a4:e7:fc
<span class="hljs-attr">TYPE</span>=Ethernet
<span class="hljs-attr">PROXY_METHOD</span>=none
<span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">BOOTPROTO</span>=none
<span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">50.100</span>
<span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>
<span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy
<span class="hljs-attr">UUID</span>=f1d52da3-<span class="hljs-number">687</span>b-<span class="hljs-number">3215</span>-a2c0-<span class="hljs-number">60</span>c11d0fd3bf
<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">AUTOCONNECT_PRIORITY</span>=-<span class="hljs-number">999</span>
<span class="hljs-attr">MTU</span>=<span class="hljs-number">9000</span>
<span class="hljs-attr">DEVICE</span>=enp1s0f1
<span class="hljs-attr">NAME</span>=enp1s0f1</code></pre></div>
<p><strong>For crate 1:</strong><br>
Follow these steps<br>
<strong>Set T1 and T2 IPs again</strong><br>
Ensure the correct IP and network base in systemVars.py, should look like this:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#File to specify what the default varaibles addresses are used in your system

#Default IP address for commercial MCH module
# our NAT MCH address
DEFAULT_HOST_IP=&quot;192.168.1.41&quot;
# our Vadatech MCH address
#DEFAULT_HOST_IP=&quot;192.168.2.15&quot;

#Default AMC13 slot number
DEFAULT_AMC13_SLOT=13

#Location of 'config_tools'. This should never need to be changed
DEFAULT_CONFIG_DIR=&quot;./config_tools&quot;

#Network base for your uTCA crate's AMC modules
NETWORK_BASE=&quot;192.168.1&quot;
#NETWORK_BASE=&quot;192.168.2&quot;</pre><pre class="hljs"><code><span class="hljs-comment">#File to specify what the default varaibles addresses are used in your system</span>

<span class="hljs-comment">#Default IP address for commercial MCH module</span>
<span class="hljs-comment"># our NAT MCH address</span>
<span class="hljs-attr">DEFAULT_HOST_IP</span>=<span class="hljs-string">&quot;192.168.1.41&quot;</span>
<span class="hljs-comment"># our Vadatech MCH address</span>
<span class="hljs-comment">#DEFAULT_HOST_IP=&quot;192.168.2.15&quot;</span>

<span class="hljs-comment">#Default AMC13 slot number</span>
<span class="hljs-attr">DEFAULT_AMC13_SLOT</span>=<span class="hljs-number">13</span>

<span class="hljs-comment">#Location of &#x27;config_tools&#x27;. This should never need to be changed</span>
<span class="hljs-attr">DEFAULT_CONFIG_DIR</span>=<span class="hljs-string">&quot;./config_tools&quot;</span>

<span class="hljs-comment">#Network base for your uTCA crate&#x27;s AMC modules</span>
<span class="hljs-attr">NETWORK_BASE</span>=<span class="hljs-string">&quot;192.168.1&quot;</span>
<span class="hljs-comment">#NETWORK_BASE=&quot;192.168.2&quot;</span></code></pre></div>
<p>Now set the IPs:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">cd /home/installation_testing/packages/experiment/lxedaq/amc13/amc13_v1_2_18/dev_tools/amc13Config
./applyConfig.py -i 192.168.1.13
The -i flag defines the T1 and T2 IP. T1 will be the argument of -i and T2 will be that argument +1 in the octet of the IP.</pre><pre class="hljs"><code><span class="hljs-keyword">cd</span> /home/installation_testing/packages/experiment/lxedaq/amc13/amc13_v1_2_18/dev_tools/amc13Config
./applyConfig.<span class="hljs-keyword">py</span> -i <span class="hljs-number">192.168</span>.<span class="hljs-number">1.13</span>
The -i flag defines the T1 <span class="hljs-built_in">and</span> T2 IP. T1 will <span class="hljs-keyword">be</span> the <span class="hljs-keyword">argument</span> of -i <span class="hljs-built_in">and</span> T2 will <span class="hljs-keyword">be</span> that <span class="hljs-keyword">argument</span> +<span class="hljs-number">1</span> in the octet of the IP.</code></pre></div>
<p>Test pinging T1 and T2:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ping 192.168.1.13
ping 192.168.1.14</pre><pre class="hljs"><code><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.1.13</span>
ping <span class="hljs-number">192.168.1.14</span></code></pre></div>
<p><strong>Configure 10GbE link</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">cd /home/installation_testing/packages/experiment/lxedaq/amc13/amc13StandaloneMAN_2014-05-12
bin/AMC13Tool -i 192.168.1.13</pre><pre class="hljs"><code><span class="hljs-attribute">cd</span> /home/installation_testing/packages/experiment/lxedaq/amc13/amc13StandaloneMAN_2014-<span class="hljs-number">05</span>-<span class="hljs-number">12</span>
<span class="hljs-attribute">bin</span>/AMC13Tool -i <span class="hljs-number">192.168.1.13</span></code></pre></div>
<p>Within AMC13Tool:</p>
<ol>
<li>Enable DAQ Link:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Pick an action (h for menu): i 0-11 d
Enabling AMC inputs from list: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Link status: 0fff0fff
Enable DAQ Link
'CONTROL1': 813f0003</pre><pre class="hljs"><code><span class="hljs-attribute">Pick an action (h for menu)</span><span class="hljs-punctuation">:</span> <span class="hljs-string">i 0-11 d</span>
<span class="hljs-attribute">Enabling AMC inputs from list</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</span>
<span class="hljs-attribute">Link status</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0fff0fff</span>
<span class="hljs-attribute">Enable DAQ Link
&#x27;CONTROL1&#x27;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">813f0003</span></code></pre></div>
Note: This has parameters:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">i &lt;ena_list&gt; (d) (f)    enable AMCs from input list. Enable  (d)AQlink, (f)ake data,
         (t) (l)    use local (T)TC signal, enable (L)ocal triggers,
         (r) (b)    TTC(r)x, monBuf (b)ackpressure</pre><pre class="hljs"><code><span class="hljs-selector-tag">i</span> &lt;ena_list&gt; (d) (f)    enable AMCs from <span class="hljs-selector-tag">input</span> list. Enable  (d)AQlink, (f)ake data,
         (t) (l)    use local (T)TC signal, enable (L)ocal triggers,
         (r) (b)    <span class="hljs-built_in">TTC</span>(r)x, monBuf (b)ackpressure</code></pre></div>
</li>
</ol>
<p>I'm not sure which one to use.</p>
<ol start="2">
<li>Enable SFP+ Ports:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Pick an action (h for menu): wv 0x3 0x1fff
Writing to T1:
  00000003: 00001fff</pre><pre class="hljs"><code><span class="hljs-attribute">Pick</span> an action (h for menu): wv <span class="hljs-number">0</span>x3 <span class="hljs-number">0</span>x1fff
<span class="hljs-attribute">Writing</span> to T1:
  <span class="hljs-attribute">00000003</span>: <span class="hljs-number">00001</span>fff</code></pre></div>
</li>
<li>Change SFP+ port IP address to 192.168.50.1:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Pick an action (h for menu): wv 0x1c1c 0xC0A83201
Writing to T1:
  00001c1c: c0a83201</pre><pre class="hljs"><code>Pick an action (h for menu): wv <span class="hljs-number">0x1c1c</span> <span class="hljs-number">0xC0A83201</span>
Writing <span class="hljs-keyword">to</span> T<span class="hljs-number">1</span>:
  <span class="hljs-number">00001</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span>: <span class="hljs-keyword">c</span><span class="hljs-number">0</span>a<span class="hljs-number">83201</span></code></pre></div>
</li>
</ol>
<p><strong>Now cycle the 10GbE port on 'be':</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ifdown enp1s0f1
ifup enp1s0f1</pre><pre class="hljs"><code>ifdown enp1s0f1
ifup enp1s0f1</code></pre></div>
<p>Try pinging</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ping 192.168.50.1</pre><pre class="hljs"><code><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.50.1</span></code></pre></div>
<p>Also ensure you can still ping the MCHs:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ping 192.168.1.41
ping 192.168.2.15</pre><pre class="hljs"><code><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.1.41</span>
ping <span class="hljs-number">192.168.2.15</span></code></pre></div>
<p>(sometimes enp1s0f1 will start stealing traffic from enp5s0. To fix this ifdown enp5s0, ifdown enp1s0f1, ifup enp5s0, ifup enp1s0f1 in that order and retry pinging).</p>
<p><strong>For crate 2:</strong><br>
Follow these steps<br>
<strong>Set T1 and T2 IPs</strong><br>
Ensure the correct IP and network base in systemVars.py, should look like this:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">#File to specify what the default varaibles addresses are used in your system

#Default IP address for commercial MCH module
# our NAT MCH address
#DEFAULT_HOST_IP=&quot;192.168.1.41&quot;
# our Vadatech MCH address
DEFAULT_HOST_IP=&quot;192.168.2.15&quot;

#Default AMC13 slot number
DEFAULT_AMC13_SLOT=13

#Location of 'config_tools'. This should never need to be changed
DEFAULT_CONFIG_DIR=&quot;./config_tools&quot;

#Network base for your uTCA crate's AMC modules
#NETWORK_BASE=&quot;192.168.1&quot;
NETWORK_BASE=&quot;192.168.2&quot;</pre><pre class="hljs"><code><span class="hljs-comment">#File to specify what the default varaibles addresses are used in your system</span>

<span class="hljs-comment">#Default IP address for commercial MCH module</span>
<span class="hljs-comment"># our NAT MCH address</span>
<span class="hljs-comment">#DEFAULT_HOST_IP=&quot;192.168.1.41&quot;</span>
<span class="hljs-comment"># our Vadatech MCH address</span>
<span class="hljs-attr">DEFAULT_HOST_IP</span>=<span class="hljs-string">&quot;192.168.2.15&quot;</span>

<span class="hljs-comment">#Default AMC13 slot number</span>
<span class="hljs-attr">DEFAULT_AMC13_SLOT</span>=<span class="hljs-number">13</span>

<span class="hljs-comment">#Location of &#x27;config_tools&#x27;. This should never need to be changed</span>
<span class="hljs-attr">DEFAULT_CONFIG_DIR</span>=<span class="hljs-string">&quot;./config_tools&quot;</span>

<span class="hljs-comment">#Network base for your uTCA crate&#x27;s AMC modules</span>
<span class="hljs-comment">#NETWORK_BASE=&quot;192.168.1&quot;</span>
<span class="hljs-attr">NETWORK_BASE</span>=<span class="hljs-string">&quot;192.168.2&quot;</span></code></pre></div>
<p>Now set the IPs:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">cd /home/installation_testing/packages/experiment/lxedaq/amc13/amc13_v1_2_18/dev_tools/amc13Config
./applyConfig.py -i 192.168.2.13
The -i flag defines the T1 and T2 IP. T1 will be the argument of -i and T2 will be that argument +1 in the octet of the IP.</pre><pre class="hljs"><code><span class="hljs-keyword">cd</span> /home/installation_testing/packages/experiment/lxedaq/amc13/amc13_v1_2_18/dev_tools/amc13Config
./applyConfig.<span class="hljs-keyword">py</span> -i <span class="hljs-number">192.168</span>.<span class="hljs-number">2.13</span>
The -i flag defines the T1 <span class="hljs-built_in">and</span> T2 IP. T1 will <span class="hljs-keyword">be</span> the <span class="hljs-keyword">argument</span> of -i <span class="hljs-built_in">and</span> T2 will <span class="hljs-keyword">be</span> that <span class="hljs-keyword">argument</span> +<span class="hljs-number">1</span> in the octet of the IP.</code></pre></div>
<p>Test pinging T1 and T2:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ping 192.168.2.13
ping 192.168.2.14</pre><pre class="hljs"><code><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.2.13</span>
ping <span class="hljs-number">192.168.2.14</span></code></pre></div>
<p><strong>Configure 10GbE link</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">cd /home/installation_testing/packages/experiment/lxedaq/amc13/amc13StandaloneMAN_2014-05-12
bin/AMC13Tool -i 192.168.2.13</pre><pre class="hljs"><code><span class="hljs-attribute">cd</span> /home/installation_testing/packages/experiment/lxedaq/amc13/amc13StandaloneMAN_2014-<span class="hljs-number">05</span>-<span class="hljs-number">12</span>
<span class="hljs-attribute">bin</span>/AMC13Tool -i <span class="hljs-number">192.168.2.13</span></code></pre></div>
<p>Within AMC13Tool:</p>
<ol>
<li>Enable DAQ Link:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Pick an action (h for menu): i 0-11 d
Enabling AMC inputs from list: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Link status: 0fff0fff
Enable DAQ Link
'CONTROL1': 813f0003</pre><pre class="hljs"><code><span class="hljs-attribute">Pick an action (h for menu)</span><span class="hljs-punctuation">:</span> <span class="hljs-string">i 0-11 d</span>
<span class="hljs-attribute">Enabling AMC inputs from list</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</span>
<span class="hljs-attribute">Link status</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0fff0fff</span>
<span class="hljs-attribute">Enable DAQ Link
&#x27;CONTROL1&#x27;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">813f0003</span></code></pre></div>
Note: This has parameters:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">i &lt;ena_list&gt; (d) (f)    enable AMCs from input list. Enable  (d)AQlink, (f)ake data,
         (t) (l)    use local (T)TC signal, enable (L)ocal triggers,
         (r) (b)    TTC(r)x, monBuf (b)ackpressure</pre><pre class="hljs"><code><span class="hljs-selector-tag">i</span> &lt;ena_list&gt; (d) (f)    enable AMCs from <span class="hljs-selector-tag">input</span> list. Enable  (d)AQlink, (f)ake data,
         (t) (l)    use local (T)TC signal, enable (L)ocal triggers,
         (r) (b)    <span class="hljs-built_in">TTC</span>(r)x, monBuf (b)ackpressure</code></pre></div>
</li>
</ol>
<p>I'm not sure which one to use.</p>
<ol start="2">
<li>Enable SFP+ Ports:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Pick an action (h for menu): wv 0x3 0x1fff
Writing to T1:
  00000003: 00001fff</pre><pre class="hljs"><code><span class="hljs-attribute">Pick</span> an action (h for menu): wv <span class="hljs-number">0</span>x3 <span class="hljs-number">0</span>x1fff
<span class="hljs-attribute">Writing</span> to T1:
  <span class="hljs-attribute">00000003</span>: <span class="hljs-number">00001</span>fff</code></pre></div>
</li>
<li>Change SFP+ port IP address to 192.168.51.1:<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Pick an action (h for menu): wv 0x1c1c 0xC0A83301
Writing to T1:
  00001c1c: c0a83301</pre><pre class="hljs"><code>Pick an action (h for menu): wv <span class="hljs-number">0x1c1c</span> <span class="hljs-number">0xC0A83301</span>
Writing <span class="hljs-keyword">to</span> T<span class="hljs-number">1</span>:
  <span class="hljs-number">00001</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span>: <span class="hljs-keyword">c</span><span class="hljs-number">0</span>a<span class="hljs-number">83301</span></code></pre></div>
</li>
</ol>
<p><strong>Now cycle the 10GbE port on 'be':</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ifdown enp1s0f0
ifup enp1s0f0</pre><pre class="hljs"><code>ifdown enp1s0f0
ifup enp1s0f0</code></pre></div>
<p>Try pinging</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ping 192.168.51.1</pre><pre class="hljs"><code><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.51.1</span></code></pre></div>
<p>Also ensure you can still ping the MCH(s):</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">ping 192.168.1.41
ping 192.168.2.15</pre><pre class="hljs"><code><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.1.41</span>
ping <span class="hljs-number">192.168.2.15</span></code></pre></div>
<p>(sometimes enp1s0f1 will start stealing traffic from enp5s0. To fix this ifdown enp5s0, ifdown enp1s0f1, ifup enp5s0, ifup enp1s0f1 in that order and retry pinging).</p>
</div></div>
					</body>
				</html>
			