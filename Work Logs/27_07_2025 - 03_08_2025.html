
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						<link rel="stylesheet" href="pluginAssets/jsdraw__markdownIt_editDrawingButton/markdownIt.css"><script type="application/javascript" src="pluginAssets/jsdraw__markdownIt_editDrawingButton/markdownIt-content.js"></script><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>27/07/2025 - 03/08/2025</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">27/07/2025 - 03/08/2025</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir Next', 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}

		:root {
			--scrollbar-size: 7px;
		}

		::-webkit-scrollbar {
			width: var(--scrollbar-size);
			height: var(--scrollbar-size);
		}
		::-webkit-scrollbar-thumb {
			border-radius: calc(var(--scrollbar-size) / 2);
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(50, 55, 63, 0.54); 
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(50, 55, 63, 0.63); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
			font-weight: bold;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		dt {
			font-weight: bold;
			margin-bottom: 0.25em;
		}

		dd {
			margin-inline-start: 2.5em;
			margin-bottom: 0.5em;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to prevent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir Next', 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		
	.not-loaded-resource img {
		width: 1.15em;
		height: 1.15em;
		background: white;
		padding: 2px !important;
		border-radius: 2px;
		box-shadow: 0 1px 3px #000000aa;
	}

	a.not-loaded-resource img {
		margin-right: .2em;
	}

	a.not-loaded-resource {
		display: flex;
		flex-direction: row;
		align-items: center;
	}


		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 35rem;
			width: 100%;
			max-width: 1000px;
			margin: 0;
			border: 0;
			display: block;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		.joplin-table-wrapper{
			overflow-x: auto;
			overflow-y: hidden;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
					position: relative;
					top: 1px;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}
.mermaid { width: 640px; }
pre.mermaid[data-processed=true] { white-space: unset; }
.mermaid-export-graph {
					opacity: 0;
					height: 0;
					z-index: 1;
					position: relative;
				} 
				.joplin-editable:hover .mermaid-export-graph,
				.joplin-editable .mermaid-export-graph:has(:focus-visible) {
					opacity: 1;
				}
				.mermaid-export-graph > button:hover {
					background-color: #CBDAF1 !important;
				}</style><div id="rendered-md"><h2 id="29072025-0045">29/07/2025 00:45</h2>
<p>These next few notes may be &quot;out of order&quot; but the sum of the information is the same.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">[root@dhcp-10-163-105-238 webpage_scripts]# iperf3 -s
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------
Accepted connection from 10.163.102.46, port 41738
[  5] local 10.163.105.238 port 5201 connected to 10.163.102.46 port 41746
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-1.01   sec  10.9 MBytes  90.1 Mbits/sec
[  5]   1.01-2.02   sec  11.2 MBytes  94.0 Mbits/sec
[  5]   2.02-3.02   sec  11.2 MBytes  93.9 Mbits/sec
[  5]   3.02-4.02   sec  11.1 MBytes  94.0 Mbits/sec
[  5]   4.02-5.02   sec  11.2 MBytes  94.0 Mbits/sec
[  5]   5.02-6.01   sec  11.1 MBytes  94.0 Mbits/sec
[  5]   6.01-7.02   sec  11.2 MBytes  93.9 Mbits/sec
[  5]   7.02-8.02   sec  11.2 MBytes  94.0 Mbits/sec
[  5]   8.02-9.01   sec  11.1 MBytes  94.0 Mbits/sec
[  5]   9.01-10.02  sec  11.2 MBytes  94.0 Mbits/sec
[  5]  10.02-10.09  sec   768 KBytes  94.0 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-10.09  sec   112 MBytes  93.6 Mbits/sec                  receiver
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------
^Ciperf3: interrupt - the server has terminated
[root@dhcp-10-163-105-238 webpage_scripts]#</pre><pre class="hljs"><code>[root@dhcp-10-163-105-238 webpage_scripts]# iperf3 -s
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------
Accepted connection from 10.163.102.46, port 41738
[  5] local 10.163.105.238 port 5201 connected to 10.163.102.46 port 41746
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-1.01   sec  10.9 MBytes  90.1 Mbits/sec
[  5]   1.01-2.02   sec  11.2 MBytes  94.0 Mbits/sec
[  5]   2.02-3.02   sec  11.2 MBytes  93.9 Mbits/sec
[  5]   3.02-4.02   sec  11.1 MBytes  94.0 Mbits/sec
[  5]   4.02-5.02   sec  11.2 MBytes  94.0 Mbits/sec
[  5]   5.02-6.01   sec  11.1 MBytes  94.0 Mbits/sec
[  5]   6.01-7.02   sec  11.2 MBytes  93.9 Mbits/sec
[  5]   7.02-8.02   sec  11.2 MBytes  94.0 Mbits/sec
[  5]   8.02-9.01   sec  11.1 MBytes  94.0 Mbits/sec
[  5]   9.01-10.02  sec  11.2 MBytes  94.0 Mbits/sec
[  5]  10.02-10.09  sec   768 KBytes  94.0 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-10.09  sec   112 MBytes  93.6 Mbits/sec                  receiver
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------
^Ciperf3: interrupt - the server has terminated
[root@dhcp-10-163-105-238 webpage_scripts]#</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">[root@dhcp-10-163-102-46 scripts]# iperf3 -c 10.163.105.238
Connecting to host 10.163.105.238, port 5201
[  5] local 10.163.102.46 port 41746 connected to 10.163.105.238 port 5201
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00-1.00   sec  13.3 MBytes   111 Mbits/sec   14    356 KBytes
[  5]   1.00-2.00   sec  11.9 MBytes   100 Mbits/sec    0    416 KBytes
[  5]   2.00-3.00   sec  10.9 MBytes  91.7 Mbits/sec    0    457 KBytes
[  5]   3.00-4.00   sec  10.9 MBytes  91.7 Mbits/sec    0    482 KBytes
[  5]   4.00-5.00   sec  11.0 MBytes  92.3 Mbits/sec    2    370 KBytes
[  5]   5.00-6.00   sec  11.9 MBytes   100 Mbits/sec    0    392 KBytes
[  5]   6.00-7.00   sec  10.9 MBytes  91.8 Mbits/sec    0    404 KBytes
[  5]   7.00-8.00   sec  10.9 MBytes  91.7 Mbits/sec    0    424 KBytes
[  5]   8.00-9.00   sec  10.9 MBytes  91.7 Mbits/sec    0    444 KBytes
[  5]   9.00-10.00  sec  11.9 MBytes   100 Mbits/sec    0    462 KBytes
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec   115 MBytes  96.3 Mbits/sec   16             sender
[  5]   0.00-10.09  sec   112 MBytes  93.6 Mbits/sec                  receiver

iperf Done.
[root@dhcp-10-163-102-46 scripts]#</pre><pre class="hljs"><code>[root@dhcp-10-163-102-46 scripts]# iperf3 -c 10.163.105.238
Connecting to host 10.163.105.238, port 5201
[  5] local 10.163.102.46 port 41746 connected to 10.163.105.238 port 5201
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00-1.00   sec  13.3 MBytes   111 Mbits/sec   14    356 KBytes
[  5]   1.00-2.00   sec  11.9 MBytes   100 Mbits/sec    0    416 KBytes
[  5]   2.00-3.00   sec  10.9 MBytes  91.7 Mbits/sec    0    457 KBytes
[  5]   3.00-4.00   sec  10.9 MBytes  91.7 Mbits/sec    0    482 KBytes
[  5]   4.00-5.00   sec  11.0 MBytes  92.3 Mbits/sec    2    370 KBytes
[  5]   5.00-6.00   sec  11.9 MBytes   100 Mbits/sec    0    392 KBytes
[  5]   6.00-7.00   sec  10.9 MBytes  91.8 Mbits/sec    0    404 KBytes
[  5]   7.00-8.00   sec  10.9 MBytes  91.7 Mbits/sec    0    424 KBytes
[  5]   8.00-9.00   sec  10.9 MBytes  91.7 Mbits/sec    0    444 KBytes
[  5]   9.00-10.00  sec  11.9 MBytes   100 Mbits/sec    0    462 KBytes
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec   115 MBytes  96.3 Mbits/sec   16             sender
[  5]   0.00-10.09  sec   112 MBytes  93.6 Mbits/sec                  receiver

iperf Done.
[root@dhcp-10-163-102-46 scripts]#</code></pre></div>
<p>Using iperf, I was able to determine the &quot;maximum throughput&quot; of the <code class="inline-code">be</code> and <code class="inline-code">fe01</code> machines over Wi-Fi.</p>
<hr>
<h2 id="29072025-0047">29/07/2025 00:47</h2>
<p>I'm running the g-2 at a rate that the DQM should be able to handle then...<br>
<img src="../_resources/573988a74f604bb68915051cb1d58a6f.png" alt="8e736fa9a51f3fa6ff78e9d3f40fe056.png"></p>
<p>But I noticed it would get events in &quot;spurts&quot; of about 40 events, before not getting any for a few seconds, then returning to get events. I added some debug code to the receiver to try to see what was going on.</p>
<h2 id="29072025-0048">29/07/2025 00:48</h2>
<p>Here's a snippet from the debug</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.184 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.184 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getInstance:39 - Returning existing singleton instance
[DEBUG] getInstance:39 - Returning existing singleton instance
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.007 seconds ago) - buffer has 613 events
[DEBUG] getLatestEvents:496 - Found 3 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 1 events (start index: 2)

=== Midas Events (count=1) ===
[EVENT] Timestamp: Tue Jul 29 00:21:46 2025
  Event ID: 1
  Trigger Mask: 65535
  Serial Number: 498574
  Data Size: 8964 bytes
  Event Header Size: 16 bytes
  Bank Header Flags: 17
  Banks (5):
    Name: CR01, Size: 8360 bytes
    Name: CA01, Size: 40 bytes
    Name: CB01, Size: 312 bytes
    Name: CZ01, Size: 8 bytes
    Name: CC01, Size: 176 bytes
  Data (first 32 bytes): 01 00 FF FF 8E 9B 07 00 5A 4C 88 68 04 23 00 00 FC 22 00 00 11 00 00 00 43 52 30 31 05 00 00 00

[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.190 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.190 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getInstance:39 - Returning existing singleton instance
[DEBUG] run:226 - cm_yield returned error status: 414
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.007 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 1 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 1 events (start index: 0)

=== Midas Events (count=1) ===
[EVENT] Timestamp: Tue Jul 29 00:21:46 2025
  Event ID: 1
  Trigger Mask: 65535
  Serial Number: 498575
  Data Size: 8964 bytes
  Event Header Size: 16 bytes
  Bank Header Flags: 17
  Banks (5):
    Name: CR01, Size: 8360 bytes
    Name: CA01, Size: 40 bytes
    Name: CB01, Size: 312 bytes
    Name: CZ01, Size: 8 bytes
    Name: CC01, Size: 176 bytes
  Data (first 32 bytes): 01 00 FF FF 8F 9B 07 00 5A 4C 88 68 04 23 00 00 FC 22 00 00 11 00 00 00 43 52 30 31 05 00 00 00

[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.195 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.195 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.009 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.200 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.200 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.014 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.205 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.205 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.020 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.211 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.211 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.025 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.216 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.216 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.030 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.</pre><pre class="hljs"><code>[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.184 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.184 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getInstance:39 - Returning existing singleton instance
[DEBUG] getInstance:39 - Returning existing singleton instance
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.007 seconds ago) - buffer has 613 events
[DEBUG] getLatestEvents:496 - Found 3 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 1 events (start index: 2)

=== Midas Events (count=1) ===
[EVENT] Timestamp: Tue Jul 29 00:21:46 2025
  Event ID: 1
  Trigger Mask: 65535
  Serial Number: 498574
  Data Size: 8964 bytes
  Event Header Size: 16 bytes
  Bank Header Flags: 17
  Banks (5):
    Name: CR01, Size: 8360 bytes
    Name: CA01, Size: 40 bytes
    Name: CB01, Size: 312 bytes
    Name: CZ01, Size: 8 bytes
    Name: CC01, Size: 176 bytes
  Data (first 32 bytes): 01 00 FF FF 8E 9B 07 00 5A 4C 88 68 04 23 00 00 FC 22 00 00 11 00 00 00 43 52 30 31 05 00 00 00

[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.190 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.190 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getInstance:39 - Returning existing singleton instance
[DEBUG] run:226 - cm_yield returned error status: 414
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.007 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 1 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 1 events (start index: 0)

=== Midas Events (count=1) ===
[EVENT] Timestamp: Tue Jul 29 00:21:46 2025
  Event ID: 1
  Trigger Mask: 65535
  Serial Number: 498575
  Data Size: 8964 bytes
  Event Header Size: 16 bytes
  Bank Header Flags: 17
  Banks (5):
    Name: CR01, Size: 8360 bytes
    Name: CA01, Size: 40 bytes
    Name: CB01, Size: 312 bytes
    Name: CZ01, Size: 8 bytes
    Name: CC01, Size: 176 bytes
  Data (first 32 bytes): 01 00 FF FF 8F 9B 07 00 5A 4C 88 68 04 23 00 00 FC 22 00 00 11 00 00 00 43 52 30 31 05 00 00 00

[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.195 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.195 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.009 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.200 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.200 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.014 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.205 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.205 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.020 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.211 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.211 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.025 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.
[DEBUG] getLatestMessages:585 - getLatestMessages(1, since 3.216 seconds ago) - buffer has 0 messages
[DEBUG] getLatestMessages:598 - Found 0 messages after timestamp
[DEBUG] getLatestMessages:604 - Returning 0 messages (start index: 0)
[DEBUG] getLatestTransitions:676 - getLatestTransitions(1, since 3.216 seconds ago) - buffer has 0 transitions
[DEBUG] getLatestTransitions:689 - Found 0 transitions after timestamp
[DEBUG] getLatestTransitions:695 - Returning 0 transitions (start index: 0)
[DEBUG] isListeningForEvents:734 - isListeningForEvents() returning: true
[DEBUG] getLatestEvents:483 - getLatestEvents(1, since 0.030 seconds ago) - buffer has 614 events
[DEBUG] getLatestEvents:496 - Found 0 events after timestamp
[DEBUG] getLatestEvents:502 - Returning 0 events (start index: 0)
[INFO] No new events.</code></pre></div>
<p>The line I particualry found interesting was:<br>
<code class="inline-code">[DEBUG] run:226 - cm_yield returned error status: 414</code><br>
which showed up every time before a pause. You can trace <code class="inline-code">414</code> back to mean <code class="inline-code">SS_CLIENT_RECV</code> in <code class="inline-code">midas.h:675</code><br>
<code class="inline-code">#define SS_CLIENT_RECV              414   /**&lt; - */</code><br>
The only place where this is returned would be in <code class="inline-code">ss_suspend</code></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">/*------------------------------------------------------------------*/
INT ss_suspend(INT millisec, INT msg)
/********************************************************************\

  Routine: ss_suspend

  Purpose: Suspend the calling thread for a specified time. If
     timeout (in millisec.) is negative, the thead is suspended
     indefinitely. It can only be resumed from another thread
     or process which calls ss_resume or by some data which
     arrives on the client or server sockets.

     If msg equals to one of MSG_BM, MSG_ODB, the function
     return whenever such a message is received. This is needed
     to break recursive calls to the event handler and db_watch() handler:

     Avoided recursion via ss_suspend(MSG_BM):

     ss_suspend(0) -&gt;
     -&gt; MSG_BM message arrives in the UDP socket
     -&gt; ss_suspend_process_ipc()
     -&gt; cm_dispatch_ipc()
     -&gt; bm_push_event()
     -&gt; bm_push_buffer()
     -&gt; bm_read_buffer()
     -&gt; bm_wait_for_more_events()
     -&gt; ss_suspend(MSG_BM) &lt;- event buffer code calls ss_suspend() with MSG_BM set
     -&gt; MSG_BM arrives arrives in the UDP socket
     -&gt; ss_suspend_process_ipc(MSG_BM)
     -&gt; the newly arrived MSG_BM message is discarded,
        recursive call to cm_dispatch_ipc(), bm_push_buffer() &amp; co avoided

     Incorrect recursion via the event handler where user called ss_suspend() without MSG_BM:

     analyzer -&gt;
     -&gt; cm_yield() in the main loop
     -&gt; ss_suspend(0)
     -&gt; MSG_BM message arrives in the UDP socket
     -&gt; ss_suspend_process_ipc(0)
     -&gt; cm_dispatch_ipc()
     -&gt; bm_push_event()
     -&gt; bm_push_buffer()
     -&gt; bm_read_buffer()
     -&gt; bm_dispatch_event()
     -&gt; user event handler
     -&gt; user event handler ROOT graphics main loop needs to sleep
     -&gt; ss_suspend(0) &lt;--- should be ss_suspend(MSG_BM)!!!     
     -&gt; MSG_BM message arrives in the UDP socket
     -&gt; ss_suspend_process_ipc(0) &lt;- should be ss_suspend_process_ipc(MSG_BM)!!!
     -&gt; cm_dispatch_ipc() &lt;- without MSG_BM, calling cm_dispatch_ipc() again
     -&gt; bm_push_event()
     -&gt; bm_push_buffer()
     -&gt; bm_read_buffer()
     -&gt; bm_dispatch_event()
     -&gt; user event handler &lt;---- called recursively, very bad!

  Input:
    INT    millisec         Timeout in milliseconds
    INT    msg              Return from ss_suspend when msg (MSG_BM, MSG_ODB) is received.

  Output:
    none

  Function value:
    SS_SUCCESS              Requested message was received
    SS_TIMEOUT              Timeout expired
    SS_SERVER_RECV          Server channel got data
    SS_CLIENT_RECV          Client channel got data
    SS_ABORT (RPC_ABORT)    Connection lost
    SS_EXIT                 Connection closed

\********************************************************************/
{
   INT status, return_status;

   midas_thread_t thread_id = ss_gettid();

   SUSPEND_STRUCT* psuspend = ss_suspend_get_struct(thread_id);

   //printf(&quot;ss_suspend: thread %s\n&quot;, ss_tid_to_string(thread_id).c_str());

   return_status = SS_TIMEOUT;

   do {
      fd_set readfds;
      FD_ZERO(&amp;readfds);

      if (ss_match_thread(_ss_listen_thread, thread_id)) {
         /* check listen sockets */
         if (_ss_server_listen_socket) {
            FD_SET(_ss_server_listen_socket, &amp;readfds);
            //printf(&quot;ss_suspend: thread %s listen ss_server socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_server_listen_socket);
         }
         
         if (_ss_client_listen_socket) {
            FD_SET(_ss_client_listen_socket, &amp;readfds);
            //printf(&quot;ss_suspend: thread %s listen ss_client socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_client_listen_socket);
         }
      }

      /* check server channels */
      if (ss_match_thread(_ss_server_thread, thread_id) &amp;&amp; _ss_server_acceptions) {
         //printf(&quot;ss_suspend: thread %s server acceptions %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_server_num_acceptions);
         for (unsigned i = 0; i &lt; _ss_server_acceptions-&gt;size(); i++) {
            /* RPC channel */
            int sock = (*_ss_server_acceptions)[i]-&gt;recv_sock;

            if (!sock)
               continue;
            
            ///* only watch the event tcp connection belonging to this thread */
            //if (_suspend_struct[idx].server_acception[i].tid != ss_gettid())
            //   continue;

            /* watch server socket if no data in cache */
            if (recv_tcp_check(sock) == 0)
               FD_SET(sock, &amp;readfds);
            /* set timeout to zero if data in cache (-&gt; just quick check IPC)
               and not called from inside bm_send_event (-&gt; wait for IPC) */
            else if (msg == 0)
               millisec = 0;

            if (msg == 0 &amp;&amp; msg != MSG_BM) {
               /* event channel */
               sock = (*_ss_server_acceptions)[i]-&gt;event_sock;

               if (!sock)
                  continue;

               /* check for buffered event */
               status = rpc_server_receive_event(0, NULL, BM_NO_WAIT);

               if (status == BM_ASYNC_RETURN) {
                  /* event buffer is full and rpc_server_receive_event() is holding on
                   * to an event it cannot get rid of. Do not read more events from
                   * the event socket, they have nowhere to go. K.O. */
               } else if (status == RPC_SUCCESS) {
                  FD_SET(sock, &amp;readfds);
               }
            }
         }
      }

      /* watch for messages from the mserver */
      if (ss_match_thread(_ss_client_thread, thread_id)) {
         if (_ss_client_connection) {
            FD_SET(_ss_client_connection-&gt;recv_sock, &amp;readfds);
         }
      }

      /* watch for UDP messages in the IPC socket: buffer and odb notifications */
      if (ss_match_thread(_ss_odb_thread, thread_id)) {
         if (_ss_suspend_odb &amp;&amp; _ss_suspend_odb-&gt;ipc_recv_socket)
            FD_SET(_ss_suspend_odb-&gt;ipc_recv_socket, &amp;readfds);
      }

      if (psuspend-&gt;ipc_recv_socket)
         FD_SET(psuspend-&gt;ipc_recv_socket, &amp;readfds);

      struct timeval timeout;

      timeout.tv_sec = millisec / 1000;
      timeout.tv_usec = (millisec % 1000) * 1000;

      do {
         //printf(&quot;select millisec %d, tv_sec %d, tv_usec %d\n&quot;, millisec, (int)timeout.tv_sec, (int)timeout.tv_usec);

         if (millisec &lt; 0)
            status = select(FD_SETSIZE, &amp;readfds, NULL, NULL, NULL);    /* blocking */
         else
            status = select(FD_SETSIZE, &amp;readfds, NULL, NULL, &amp;timeout);

         /* if an alarm signal was cought, restart select with reduced timeout */
         if (status == -1 &amp;&amp; timeout.tv_sec &gt;= WATCHDOG_INTERVAL / 1000)
            timeout.tv_sec -= WATCHDOG_INTERVAL / 1000;

      } while (status == -1);   /* dont return if an alarm signal was cought */

      /* check listener sockets */

      if (_ss_server_listen_socket &amp;&amp; FD_ISSET(_ss_server_listen_socket, &amp;readfds)) {
         //printf(&quot;ss_suspend: thread %s rpc_server_accept socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_server_listen_socket);
         status = rpc_server_accept(_ss_server_listen_socket);
         if (status == RPC_SHUTDOWN) {
            return status;
         }
      }

      if (_ss_client_listen_socket &amp;&amp; FD_ISSET(_ss_client_listen_socket, &amp;readfds)) {
         //printf(&quot;ss_suspend: thread %s rpc_client_accept socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_client_listen_socket);
         status = rpc_client_accept(_ss_client_listen_socket);
         if (status == RPC_SHUTDOWN) {
            return status;
         }
      }

      /* check server channels */
      if (_ss_server_acceptions) {
         for (unsigned i = 0; i &lt; _ss_server_acceptions-&gt;size(); i++) {
            /* rpc channel */
            int sock = (*_ss_server_acceptions)[i]-&gt;recv_sock;

            if (!sock)
               continue;
            
            //printf(&quot;rpc index %d, socket %d, hostname \'%s\', progname \'%s\'\n&quot;, i, sock, _suspend_struct[idx].server_acception[i].host_name, _suspend_struct[idx].server_acception[i].prog_name);

            if (recv_tcp_check(sock) || FD_ISSET(sock, &amp;readfds)) {
               //printf(&quot;ss_suspend: msg %d\n&quot;, msg);
               if (msg == MSG_BM) {
                  status = ss_socket_check(sock);
               } else {
                  //printf(&quot;ss_suspend: rpc_server_receive_rpc() call!\n&quot;);
                  status = rpc_server_receive_rpc(i, (*_ss_server_acceptions)[i]);
                  //printf(&quot;ss_suspend: rpc_server_receive_rpc() status %d\n&quot;, status);
               }
               (*_ss_server_acceptions)[i]-&gt;last_activity = ss_millitime();

               if (status == SS_ABORT || status == SS_EXIT || status == RPC_SHUTDOWN) {
                  return status;
               }
               
               return_status = SS_SERVER_RECV;
            }

            /* event channel */
            sock = (*_ss_server_acceptions)[i]-&gt;event_sock;

            if (!sock)
               continue;

            if (FD_ISSET(sock, &amp;readfds)) {
               if (msg != 0) {
                  status = ss_socket_check(sock);
               } else {
                  //printf(&quot;ss_suspend: rpc_server_receive_event() call!\n&quot;);
                  status = rpc_server_receive_event(i, (*_ss_server_acceptions)[i], BM_NO_WAIT);
                  //printf(&quot;ss_suspend: rpc_server_receive_event() status %d\n&quot;, status);
               }
               (*_ss_server_acceptions)[i]-&gt;last_activity = ss_millitime();

               if (status == SS_ABORT || status == SS_EXIT || status == RPC_SHUTDOWN) {
                  return status;
               }
               
               return_status = SS_SERVER_RECV;
            }
         }
      }

      /* check for messages from the mserver */
      if (_ss_client_connection) {
         int sock = _ss_client_connection-&gt;recv_sock;

         if (FD_ISSET(sock, &amp;readfds)) {
            status = rpc_client_dispatch(sock);

            if (status == SS_ABORT) {
               cm_msg(MINFO, &quot;ss_suspend&quot;, &quot;RPC connection to mserver at \'%s\' was broken&quot;, _ss_client_connection-&gt;host_name.c_str());

               /* close client connection if link broken */
               closesocket(_ss_client_connection-&gt;send_sock);
               closesocket(_ss_client_connection-&gt;recv_sock);
               closesocket(_ss_client_connection-&gt;event_sock);

               _ss_client_connection-&gt;send_sock = 0;
               _ss_client_connection-&gt;recv_sock = 0;
               _ss_client_connection-&gt;event_sock = 0;
            
               _ss_client_connection-&gt;clear();

               /* exit program after broken connection to MIDAS server */
               return SS_ABORT;
            }

            return_status = SS_CLIENT_RECV;
         }
      }

      /* check ODB IPC socket */
      if (_ss_suspend_odb &amp;&amp; _ss_suspend_odb-&gt;ipc_recv_socket &amp;&amp; FD_ISSET(_ss_suspend_odb-&gt;ipc_recv_socket, &amp;readfds)) {
         status = ss_suspend_process_ipc(millisec, msg, _ss_suspend_odb-&gt;ipc_recv_socket);
         if (status) {
            return status;
         }
      }
      
      /* check per-thread IPC socket */
      if (psuspend &amp;&amp; psuspend-&gt;ipc_recv_socket &amp;&amp; FD_ISSET(psuspend-&gt;ipc_recv_socket, &amp;readfds)) {
         status = ss_suspend_process_ipc(millisec, msg, psuspend-&gt;ipc_recv_socket);
         if (status) {
            return status;
         }
      }


   } while (millisec &lt; 0);

   return return_status;
}</pre><pre class="hljs"><code>/*------------------------------------------------------------------*/
INT ss_suspend(INT millisec, INT msg)
/********************************************************************\

  Routine: ss_suspend

  Purpose: Suspend the calling thread for a specified time. If
     timeout (in millisec.) is negative, the thead is suspended
     indefinitely. It can only be resumed from another thread
     or process which calls ss_resume or by some data which
     arrives on the client or server sockets.

     If msg equals to one of MSG_BM, MSG_ODB, the function
     return whenever such a message is received. This is needed
     to break recursive calls to the event handler and db_watch() handler:

     Avoided recursion via ss_suspend(MSG_BM):

     ss_suspend(0) -&gt;
     -&gt; MSG_BM message arrives in the UDP socket
     -&gt; ss_suspend_process_ipc()
     -&gt; cm_dispatch_ipc()
     -&gt; bm_push_event()
     -&gt; bm_push_buffer()
     -&gt; bm_read_buffer()
     -&gt; bm_wait_for_more_events()
     -&gt; ss_suspend(MSG_BM) &lt;- event buffer code calls ss_suspend() with MSG_BM set
     -&gt; MSG_BM arrives arrives in the UDP socket
     -&gt; ss_suspend_process_ipc(MSG_BM)
     -&gt; the newly arrived MSG_BM message is discarded,
        recursive call to cm_dispatch_ipc(), bm_push_buffer() &amp; co avoided

     Incorrect recursion via the event handler where user called ss_suspend() without MSG_BM:

     analyzer -&gt;
     -&gt; cm_yield() in the main loop
     -&gt; ss_suspend(0)
     -&gt; MSG_BM message arrives in the UDP socket
     -&gt; ss_suspend_process_ipc(0)
     -&gt; cm_dispatch_ipc()
     -&gt; bm_push_event()
     -&gt; bm_push_buffer()
     -&gt; bm_read_buffer()
     -&gt; bm_dispatch_event()
     -&gt; user event handler
     -&gt; user event handler ROOT graphics main loop needs to sleep
     -&gt; ss_suspend(0) &lt;--- should be ss_suspend(MSG_BM)!!!     
     -&gt; MSG_BM message arrives in the UDP socket
     -&gt; ss_suspend_process_ipc(0) &lt;- should be ss_suspend_process_ipc(MSG_BM)!!!
     -&gt; cm_dispatch_ipc() &lt;- without MSG_BM, calling cm_dispatch_ipc() again
     -&gt; bm_push_event()
     -&gt; bm_push_buffer()
     -&gt; bm_read_buffer()
     -&gt; bm_dispatch_event()
     -&gt; user event handler &lt;---- called recursively, very bad!

  Input:
    INT    millisec         Timeout in milliseconds
    INT    msg              Return from ss_suspend when msg (MSG_BM, MSG_ODB) is received.

  Output:
    none

  Function value:
    SS_SUCCESS              Requested message was received
    SS_TIMEOUT              Timeout expired
    SS_SERVER_RECV          Server channel got data
    SS_CLIENT_RECV          Client channel got data
    SS_ABORT (RPC_ABORT)    Connection lost
    SS_EXIT                 Connection closed

\********************************************************************/
{
   INT status, return_status;

   midas_thread_t thread_id = ss_gettid();

   SUSPEND_STRUCT* psuspend = ss_suspend_get_struct(thread_id);

   //printf(&quot;ss_suspend: thread %s\n&quot;, ss_tid_to_string(thread_id).c_str());

   return_status = SS_TIMEOUT;

   do {
      fd_set readfds;
      FD_ZERO(&amp;readfds);

      if (ss_match_thread(_ss_listen_thread, thread_id)) {
         /* check listen sockets */
         if (_ss_server_listen_socket) {
            FD_SET(_ss_server_listen_socket, &amp;readfds);
            //printf(&quot;ss_suspend: thread %s listen ss_server socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_server_listen_socket);
         }
         
         if (_ss_client_listen_socket) {
            FD_SET(_ss_client_listen_socket, &amp;readfds);
            //printf(&quot;ss_suspend: thread %s listen ss_client socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_client_listen_socket);
         }
      }

      /* check server channels */
      if (ss_match_thread(_ss_server_thread, thread_id) &amp;&amp; _ss_server_acceptions) {
         //printf(&quot;ss_suspend: thread %s server acceptions %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_server_num_acceptions);
         for (unsigned i = 0; i &lt; _ss_server_acceptions-&gt;size(); i++) {
            /* RPC channel */
            int sock = (*_ss_server_acceptions)[i]-&gt;recv_sock;

            if (!sock)
               continue;
            
            ///* only watch the event tcp connection belonging to this thread */
            //if (_suspend_struct[idx].server_acception[i].tid != ss_gettid())
            //   continue;

            /* watch server socket if no data in cache */
            if (recv_tcp_check(sock) == 0)
               FD_SET(sock, &amp;readfds);
            /* set timeout to zero if data in cache (-&gt; just quick check IPC)
               and not called from inside bm_send_event (-&gt; wait for IPC) */
            else if (msg == 0)
               millisec = 0;

            if (msg == 0 &amp;&amp; msg != MSG_BM) {
               /* event channel */
               sock = (*_ss_server_acceptions)[i]-&gt;event_sock;

               if (!sock)
                  continue;

               /* check for buffered event */
               status = rpc_server_receive_event(0, NULL, BM_NO_WAIT);

               if (status == BM_ASYNC_RETURN) {
                  /* event buffer is full and rpc_server_receive_event() is holding on
                   * to an event it cannot get rid of. Do not read more events from
                   * the event socket, they have nowhere to go. K.O. */
               } else if (status == RPC_SUCCESS) {
                  FD_SET(sock, &amp;readfds);
               }
            }
         }
      }

      /* watch for messages from the mserver */
      if (ss_match_thread(_ss_client_thread, thread_id)) {
         if (_ss_client_connection) {
            FD_SET(_ss_client_connection-&gt;recv_sock, &amp;readfds);
         }
      }

      /* watch for UDP messages in the IPC socket: buffer and odb notifications */
      if (ss_match_thread(_ss_odb_thread, thread_id)) {
         if (_ss_suspend_odb &amp;&amp; _ss_suspend_odb-&gt;ipc_recv_socket)
            FD_SET(_ss_suspend_odb-&gt;ipc_recv_socket, &amp;readfds);
      }

      if (psuspend-&gt;ipc_recv_socket)
         FD_SET(psuspend-&gt;ipc_recv_socket, &amp;readfds);

      struct timeval timeout;

      timeout.tv_sec = millisec / 1000;
      timeout.tv_usec = (millisec % 1000) * 1000;

      do {
         //printf(&quot;select millisec %d, tv_sec %d, tv_usec %d\n&quot;, millisec, (int)timeout.tv_sec, (int)timeout.tv_usec);

         if (millisec &lt; 0)
            status = select(FD_SETSIZE, &amp;readfds, NULL, NULL, NULL);    /* blocking */
         else
            status = select(FD_SETSIZE, &amp;readfds, NULL, NULL, &amp;timeout);

         /* if an alarm signal was cought, restart select with reduced timeout */
         if (status == -1 &amp;&amp; timeout.tv_sec &gt;= WATCHDOG_INTERVAL / 1000)
            timeout.tv_sec -= WATCHDOG_INTERVAL / 1000;

      } while (status == -1);   /* dont return if an alarm signal was cought */

      /* check listener sockets */

      if (_ss_server_listen_socket &amp;&amp; FD_ISSET(_ss_server_listen_socket, &amp;readfds)) {
         //printf(&quot;ss_suspend: thread %s rpc_server_accept socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_server_listen_socket);
         status = rpc_server_accept(_ss_server_listen_socket);
         if (status == RPC_SHUTDOWN) {
            return status;
         }
      }

      if (_ss_client_listen_socket &amp;&amp; FD_ISSET(_ss_client_listen_socket, &amp;readfds)) {
         //printf(&quot;ss_suspend: thread %s rpc_client_accept socket %d\n&quot;, ss_tid_to_string(thread_id).c_str(), _ss_client_listen_socket);
         status = rpc_client_accept(_ss_client_listen_socket);
         if (status == RPC_SHUTDOWN) {
            return status;
         }
      }

      /* check server channels */
      if (_ss_server_acceptions) {
         for (unsigned i = 0; i &lt; _ss_server_acceptions-&gt;size(); i++) {
            /* rpc channel */
            int sock = (*_ss_server_acceptions)[i]-&gt;recv_sock;

            if (!sock)
               continue;
            
            //printf(&quot;rpc index %d, socket %d, hostname \'%s\', progname \'%s\'\n&quot;, i, sock, _suspend_struct[idx].server_acception[i].host_name, _suspend_struct[idx].server_acception[i].prog_name);

            if (recv_tcp_check(sock) || FD_ISSET(sock, &amp;readfds)) {
               //printf(&quot;ss_suspend: msg %d\n&quot;, msg);
               if (msg == MSG_BM) {
                  status = ss_socket_check(sock);
               } else {
                  //printf(&quot;ss_suspend: rpc_server_receive_rpc() call!\n&quot;);
                  status = rpc_server_receive_rpc(i, (*_ss_server_acceptions)[i]);
                  //printf(&quot;ss_suspend: rpc_server_receive_rpc() status %d\n&quot;, status);
               }
               (*_ss_server_acceptions)[i]-&gt;last_activity = ss_millitime();

               if (status == SS_ABORT || status == SS_EXIT || status == RPC_SHUTDOWN) {
                  return status;
               }
               
               return_status = SS_SERVER_RECV;
            }

            /* event channel */
            sock = (*_ss_server_acceptions)[i]-&gt;event_sock;

            if (!sock)
               continue;

            if (FD_ISSET(sock, &amp;readfds)) {
               if (msg != 0) {
                  status = ss_socket_check(sock);
               } else {
                  //printf(&quot;ss_suspend: rpc_server_receive_event() call!\n&quot;);
                  status = rpc_server_receive_event(i, (*_ss_server_acceptions)[i], BM_NO_WAIT);
                  //printf(&quot;ss_suspend: rpc_server_receive_event() status %d\n&quot;, status);
               }
               (*_ss_server_acceptions)[i]-&gt;last_activity = ss_millitime();

               if (status == SS_ABORT || status == SS_EXIT || status == RPC_SHUTDOWN) {
                  return status;
               }
               
               return_status = SS_SERVER_RECV;
            }
         }
      }

      /* check for messages from the mserver */
      if (_ss_client_connection) {
         int sock = _ss_client_connection-&gt;recv_sock;

         if (FD_ISSET(sock, &amp;readfds)) {
            status = rpc_client_dispatch(sock);

            if (status == SS_ABORT) {
               cm_msg(MINFO, &quot;ss_suspend&quot;, &quot;RPC connection to mserver at \'%s\' was broken&quot;, _ss_client_connection-&gt;host_name.c_str());

               /* close client connection if link broken */
               closesocket(_ss_client_connection-&gt;send_sock);
               closesocket(_ss_client_connection-&gt;recv_sock);
               closesocket(_ss_client_connection-&gt;event_sock);

               _ss_client_connection-&gt;send_sock = 0;
               _ss_client_connection-&gt;recv_sock = 0;
               _ss_client_connection-&gt;event_sock = 0;
            
               _ss_client_connection-&gt;clear();

               /* exit program after broken connection to MIDAS server */
               return SS_ABORT;
            }

            return_status = SS_CLIENT_RECV;
         }
      }

      /* check ODB IPC socket */
      if (_ss_suspend_odb &amp;&amp; _ss_suspend_odb-&gt;ipc_recv_socket &amp;&amp; FD_ISSET(_ss_suspend_odb-&gt;ipc_recv_socket, &amp;readfds)) {
         status = ss_suspend_process_ipc(millisec, msg, _ss_suspend_odb-&gt;ipc_recv_socket);
         if (status) {
            return status;
         }
      }
      
      /* check per-thread IPC socket */
      if (psuspend &amp;&amp; psuspend-&gt;ipc_recv_socket &amp;&amp; FD_ISSET(psuspend-&gt;ipc_recv_socket, &amp;readfds)) {
         status = ss_suspend_process_ipc(millisec, msg, psuspend-&gt;ipc_recv_socket);
         if (status) {
            return status;
         }
      }


   } while (millisec &lt; 0);

   return return_status;
}</code></pre></div>
<p>which is called in lots of places, but in our case it comes from <code class="inline-code">cm_yield</code></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">INT cm_yield(INT millisec) {
   INT status;
   INT bMore;
   //static DWORD last_yield = 0;
   //static DWORD last_yield_time = 0;
   //DWORD start_yield = ss_millitime();

   /* check for ctrl-c */
   if (_ctrlc_pressed)
      return RPC_SHUTDOWN;

   /* flush the cm_msg buffer */
   cm_msg_flush_buffer();

   if (!rpc_is_remote()) {
      /* flush the ODB to its binary file */
      /* for remote clients, ODB is flushed by the mserver */
      HNDLE hDB;
      cm_get_experiment_database(&amp;hDB, NULL);
      db_flush_database(hDB);
   }

   /* check for available events */
   if (rpc_is_remote()) {
      //printf(&quot;cm_yield() calling bm_poll_event()\n&quot;);
      status = bm_poll_event();

      if (status == SS_ABORT) {
         return status;
      }

      if (status == BM_SUCCESS) {
         /* one or more events received by bm_poll_event() */
         status = ss_suspend(0, 0);
      } else {
         status = ss_suspend(millisec, 0);
      }

      return status;
   }

   status = cm_periodic_tasks();

   if (status != CM_SUCCESS)
      return status;

   //DWORD start_check = ss_millitime();

   bMore = bm_check_buffers();

   //DWORD end_check = ss_millitime();
   //printf(&quot;cm_yield: timeout %4d, yield period %4d, last yield time %4d, bm_check_buffers() elapsed %4d, returned %d\n&quot;, millisec, start_yield - last_yield, last_yield_time, end_check - start_check, bMore);
   //fflush(stdout);

   if (bMore == BM_CORRUPTED) {
      status = SS_ABORT;
   } else if (bMore) {
      /* if events available, quickly check other IPC channels */
      status = ss_suspend(0, 0);
   } else {
      status = ss_suspend(millisec, 0);
   }

   /* flush the cm_msg buffer */
   cm_msg_flush_buffer();

   //DWORD end_yield = ss_millitime();
   //last_yield_time = end_yield - start_yield;
   //last_yield = start_yield;

   return status;
}</pre><pre class="hljs"><code>INT cm_yield(INT millisec) {
   INT status;
   INT bMore;
   //static DWORD last_yield = 0;
   //static DWORD last_yield_time = 0;
   //DWORD start_yield = ss_millitime();

   /* check for ctrl-c */
   if (_ctrlc_pressed)
      return RPC_SHUTDOWN;

   /* flush the cm_msg buffer */
   cm_msg_flush_buffer();

   if (!rpc_is_remote()) {
      /* flush the ODB to its binary file */
      /* for remote clients, ODB is flushed by the mserver */
      HNDLE hDB;
      cm_get_experiment_database(&amp;hDB, NULL);
      db_flush_database(hDB);
   }

   /* check for available events */
   if (rpc_is_remote()) {
      //printf(&quot;cm_yield() calling bm_poll_event()\n&quot;);
      status = bm_poll_event();

      if (status == SS_ABORT) {
         return status;
      }

      if (status == BM_SUCCESS) {
         /* one or more events received by bm_poll_event() */
         status = ss_suspend(0, 0);
      } else {
         status = ss_suspend(millisec, 0);
      }

      return status;
   }

   status = cm_periodic_tasks();

   if (status != CM_SUCCESS)
      return status;

   //DWORD start_check = ss_millitime();

   bMore = bm_check_buffers();

   //DWORD end_check = ss_millitime();
   //printf(&quot;cm_yield: timeout %4d, yield period %4d, last yield time %4d, bm_check_buffers() elapsed %4d, returned %d\n&quot;, millisec, start_yield - last_yield, last_yield_time, end_check - start_check, bMore);
   //fflush(stdout);

   if (bMore == BM_CORRUPTED) {
      status = SS_ABORT;
   } else if (bMore) {
      /* if events available, quickly check other IPC channels */
      status = ss_suspend(0, 0);
   } else {
      status = ss_suspend(millisec, 0);
   }

   /* flush the cm_msg buffer */
   cm_msg_flush_buffer();

   //DWORD end_yield = ss_millitime();
   //last_yield_time = end_yield - start_yield;
   //last_yield = start_yield;

   return status;
}</code></pre></div>
<h2 id="29072025-0057">29/07/2025 00:57</h2>
<p>It seems changing</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">status = cm_yield(1);</pre><pre class="hljs"><code><span class="hljs-attribute">status</span> <span class="hljs-operator">=</span> cm_yield(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span></code></pre></div>
<p>to be lower fixes this issue</p>
<hr>
<h2 id="29072025-0115">29/07/2025 01:15</h2>
<p>After some tests it appears shortening the yield timeout was the solution. I think midas uses this to say &quot;okay, this program is going to chill for this many milliseconds so other programs can catch up.&quot; But it was hard to tell exactly from reading the code what this parameter does.</p>
<hr>
</div></div>
					</body>
				</html>
			